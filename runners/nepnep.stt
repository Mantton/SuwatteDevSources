(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.STTPackage = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IMAGE_HOST = exports.DEFAULT_FILTERS = exports.SEARCH_SORTERS = exports.TAG_PREFIX = exports.SORT_KEYS = exports.PATHS = exports.HIGHLIGHT_LIMIT = exports.BASE_EXPLORE_COLLECTIONS = exports.VERTICAL_TYPES = exports.ADULT_TAGS = exports.STATUS_KEYS = exports.NEPNEP_DOMAINS = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const lodash_1 = require("lodash");
exports.NEPNEP_DOMAINS = [
    {
        name: "MangaSee",
        url: "https://mangasee123.com",
        id: "see",
    },
    {
        name: "MangaLife",
        url: "https://manga4life.com",
        id: "life",
    },
];
const STATUSES = ["ongoing", "complete", "hiatus", "discontinued", "cancelled"];
exports.STATUS_KEYS = {
    ongoing: daisuke_1.Status.ONGOING,
    complete: daisuke_1.Status.COMPLETED,
    hiatus: daisuke_1.Status.HIATUS,
    cancelled: daisuke_1.Status.CANCELLED,
    discontinued: daisuke_1.Status.CANCELLED,
};
exports.ADULT_TAGS = ["mature", "adult", "hentai", "smut"];
exports.VERTICAL_TYPES = ["OEL", "Manhwa", "Manhua"];
exports.BASE_EXPLORE_COLLECTIONS = [
    {
        id: "trending",
        title: "Trending Titles ",
        subtitle: "Hottest updates being read right now!",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "admin_recommendations",
        title: "Admin Recommendations",
        subtitle: "Titles worth your time",
        style: daisuke_1.CollectionStyle.GALLERY,
    },
    {
        id: "hot_monthly",
        title: "Top Titles This Month ",
        subtitle: "Certified Bangers",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "new",
        title: "New Titles",
        subtitle: "Just added to the site.",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "latest",
        title: "Latest Updates ",
        subtitle: "Top of the morning.",
        style: daisuke_1.CollectionStyle.UPDATE_LIST,
    },
];
exports.HIGHLIGHT_LIMIT = 30;
exports.PATHS = {
    trending: /vm.HotUpdateJSON = (.*);/,
    latest: /vm.LatestJSON = (.*);/,
    admin_recommendations: /vm.RecommendationJSON = (.*);/,
    new: /vm.NewSeriesJSON = (.*);/,
    chapters: /vm.Chapters = (.*);/,
    full_directory: /vm.FullDirectory = (.*);/,
    directory: /vm.Directory = (.*);/,
    related: /vm.RelatedSeriesJSON = (.*);/,
    hot_monthly: /vm.TopTenJSON = (.*);/,
    genre_tag: /"Genre"\s*: (.*)/,
    format_tag: /"Type"\s*: (.*),/g,
    chapter_data_domain: /vm.CurPathName = (.*);/,
    chapter_data_path: /vm.IndexName = (.*);/,
    chapter_data_chapter: /vm.CurChapter = (.*);/,
};
exports.SORT_KEYS = {
    views_all: "v",
    views_monthly: "vm",
    recent: "lt",
    alphabetically: "s",
};
exports.TAG_PREFIX = {
    publication: "p_status",
    scanlation: "s_status",
    type: "type",
    year: "released",
    lang: "o_translation",
    author: "author",
    translation: "translation",
    genres: "genres",
};
exports.SEARCH_SORTERS = [
    {
        id: "views_all",
        label: "Most Popular (All Time)",
    },
    {
        id: "views_monthly",
        label: "Most Popular (Monthly)",
    },
    {
        id: "recent",
        label: "Recently Released Chapter",
    },
    {
        id: "alphabetically",
        label: "Alphabetically",
    },
];
exports.DEFAULT_FILTERS = [
    {
        id: exports.TAG_PREFIX.publication,
        title: "Publication Status",
        type: daisuke_1.FilterType.MULTISELECT,
        options: STATUSES.map((v) => ({ id: v, label: (0, lodash_1.capitalize)(v) })),
    },
    {
        id: exports.TAG_PREFIX.scanlation,
        title: "Scan Status",
        options: STATUSES.map((v) => ({ id: v, label: (0, lodash_1.capitalize)(v) })),
        type: daisuke_1.FilterType.MULTISELECT,
    },
    {
        id: exports.TAG_PREFIX.translation,
        title: "Translation Status",
        label: "Official Translation Only",
        type: daisuke_1.FilterType.TOGGLE,
    },
];
exports.IMAGE_HOST = "https://cover.mangabeast01.com/cover";

},{"@suwatte/daisuke":9,"lodash":"lodash"}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Controller = void 0;
const constants_1 = require("./constants");
const parser_1 = require("./parser");
const store_1 = require("./store");
const utils_1 = require("./utils");
class Controller {
    client = new NetworkClient();
    parser = new parser_1.Parser();
    store = new store_1.Store();
    directory = [];
    directoryHTML = "";
    homepage = "";
    // Directory
    async getDirectoryString() {
        if (this.directoryHTML) {
            return this.directoryHTML;
        }
        const url = await this.store.host();
        const response = await this.client.get(`${url}/search`);
        const html = response.data;
        this.directoryHTML = html;
        return this.directoryHTML;
    }
    async fetchDirectory() {
        const html = await this.getDirectoryString();
        const regex = constants_1.PATHS.directory;
        const dirStr = html.match(regex)?.[1];
        if (!dirStr)
            throw new Error("Failed to parse NepNep Directory");
        this.directory = JSON.parse(dirStr);
    }
    async fetchHomePage() {
        const host = await this.store.host();
        const response = await this.client.get(host);
        this.homepage = response.data;
        const temp = this.homepage.match(/ng-src="(.*\.jpg)"/)?.[1];
        if (temp)
            this.parser.THUMBNAIL_TEMPLATE = temp;
    }
    // Explore
    async resolveExcerpt(excerpt) {
        const regex = constants_1.PATHS[excerpt.id];
        const str = this.homepage.match(regex)?.[1];
        if (!str)
            throw new Error("Failed to Match HomePage Section");
        const highlights = this.parser.homepageSection(JSON.parse(str));
        return { ...excerpt, highlights };
    }
    // Search
    async getFilters() {
        const html = await this.getDirectoryString();
        return this.parser.filters(html);
    }
    async getSearchResults(request) {
        // Populate if empty
        if (this.directory.length == 0) {
            await this.fetchDirectory();
        }
        const temp = this.directoryHTML.match(/ng-src="(.*\.jpg)"/)?.[1];
        if (temp)
            this.parser.THUMBNAIL_TEMPLATE = temp;
        const key = constants_1.SORT_KEYS[request.sort ?? ""] ?? "v";
        const parsed = this.parser.search(request);
        const matches = this.directory.filter((v) => this.matchesRequest(v, parsed));
        const page = request.page ?? 1;
        const min = constants_1.HIGHLIGHT_LIMIT * (page - 1);
        const max = constants_1.HIGHLIGHT_LIMIT * page;
        if (key !== "s") {
            matches.sort((0, utils_1.dynamicSort)(key));
        }
        const results = matches
            .slice(min, max)
            .map((v) => this.parser.toHighlight(v));
        return {
            page,
            results,
            isLastPage: results.length <= constants_1.HIGHLIGHT_LIMIT,
            totalResultCount: matches.length,
        };
    }
    matchesRequest(entry, request) {
        let match = true;
        // Author
        if (request.authors && request.authors.length > 0) {
            const hasAuthor = (name) => {
                return (entry.a ?? [])
                    .map((v) => v.toLowerCase().trim())
                    .includes(name.toLowerCase().trim());
            };
            match = request.authors.some(hasAuthor);
            // Check
            if (!match) {
                return false;
            }
        }
        // Query
        if (request.query) {
            const str = [...(entry.al ?? []), entry.s].join(" ");
            match = str.toLowerCase().includes(request.query.toLowerCase());
            // Check
            if (!match) {
                return false;
            }
        }
        // Release Year
        if (request.released) {
            match = entry.y == request.released;
            // Check
            if (!match) {
                return false;
            }
        }
        // Official Translation
        if (request.originalTranslation) {
            match = entry.o === "yes";
            // Check
            if (!match) {
                return false;
            }
        }
        // Included Types
        if (request.includeTypes && request.includeTypes.length > 0) {
            match = request.includeTypes.includes(entry.t.toLowerCase());
            // Check
            if (!match) {
                return false;
            }
        }
        // Excluded Types
        if (request.excludeTypes && request.excludeTypes.length > 0) {
            match = !request.excludeTypes.includes(entry.t.toLowerCase());
            // Check
            if (!match) {
                return false;
            }
        }
        // Scan Status
        if (request.s_status && request.s_status.length > 0) {
            match = request.s_status.includes(entry.ss.toLowerCase());
            // Check
            if (!match) {
                return false;
            }
        }
        // Publication Status
        if (request.p_status && request.p_status.length > 0) {
            match = request.p_status.includes(entry.ps.toLowerCase());
            // Check
            if (!match) {
                return false;
            }
        }
        /**
         * checks if the entry's genre list contains provided genre
         * @param v Genre Name
         */
        const hasTag = (v) => {
            return (entry.g ?? [])
                .map((v) => v.toLowerCase().trim())
                .includes(v.toLowerCase().trim());
        };
        // Included Tags
        if (request.includedTags && request.includedTags.length > 0) {
            match = request.includedTags.every(hasTag);
            // Check
            if (!match) {
                return false;
            }
        }
        // Excluded Tags
        if (request.excludedTags && request.excludedTags.length > 0) {
            match = !request.excludedTags.some(hasTag);
            if (!match) {
                return false;
            }
        }
        return true;
    }
    // Content
    async getContent(id) {
        const host = await this.store.host();
        const response = await this.client.get(`${host}/manga/${id}`);
        const html = response.data;
        return this.parser.content(html, id, host);
    }
    // Chapters
    async getChapters(id) {
        const host = await this.store.host();
        const response = await this.client.get(`${host}/manga/${id}`);
        const html = response.data;
        return this.parser.chapters(html, id);
    }
    async getChapterData(contentId, chapterId) {
        const host = await this.store.host();
        const suffix = (0, utils_1.prepareURLSuffix)(chapterId);
        const url = `${host}/read-online/${contentId}${suffix}`;
        const response = await this.client.get(url);
        return this.parser.chapterData(response.data, chapterId, contentId);
    }
}
exports.Controller = Controller;

},{"./constants":1,"./parser":4,"./store":5,"./utils":6}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const lodash_1 = require("lodash");
const constants_1 = require("./constants");
const controller_1 = require("./controller");
class Target extends daisuke_1.Source {
    info = {
        id: "m.nepnep",
        website: "https://mangasee123.com",
        version: 1.3,
        name: "NepNep",
        supportedLanguages: ["EN_US"],
        nsfw: false,
        authors: ["Mantton"],
        thumbnail: "nepnep.png",
        minSupportedAppVersion: "5.0",
    };
    controller = new controller_1.Controller();
    async getContent(contentId) {
        return this.controller.getContent(contentId);
    }
    async getChapters(contentId) {
        return this.controller.getChapters(contentId);
    }
    async getChapterData(contentId, chapterId) {
        return this.controller.getChapterData(contentId, chapterId);
    }
    async getSourceTags() {
        const filters = await this.controller.getFilters();
        return filters
            .map((v) => ({
            id: v.id,
            label: v.title,
            tags: (v.options ?? []).map((v) => ({
                ...v,
                adultContent: constants_1.ADULT_TAGS.includes(v.id),
            })),
        }))
            .filter((v) => v.tags.length != 0);
    }
    async createExploreCollections() {
        // Refresh
        return constants_1.BASE_EXPLORE_COLLECTIONS;
    }
    willResolveExploreCollections() {
        return this.controller.fetchHomePage();
    }
    async resolveExploreCollection(excerpt) {
        return await this.controller.resolveExcerpt(excerpt);
    }
    async getExplorePageTags() {
        const tags = (await this.getSourceTags())[0].tags.filter((v) => !v.adultContent);
        const selected = (0, lodash_1.sampleSize)(tags, 7);
        return selected.map((v) => ({
            ...v,
            request: { filters: [{ id: "genres", included: [v.id] }] },
        }));
    }
    // Searching
    async getSearchSorters() {
        return constants_1.SEARCH_SORTERS;
    }
    async getSearchFilters() {
        return this.controller.getFilters();
    }
    async getSearchResults(query) {
        return this.controller.getSearchResults(query);
    }
    // Preference
    async getSourcePreferences() {
        const store = new ObjectStore();
        return [
            {
                id: "general",
                header: "General",
                children: [
                    new daisuke_1.SelectPreference({
                        key: "host",
                        label: "NepNep Site",
                        options: constants_1.NEPNEP_DOMAINS.map((v) => ({
                            label: v.name,
                            value: v.id,
                        })),
                        value: {
                            get: async () => {
                                const stored = await store.string("n_host");
                                const def = constants_1.NEPNEP_DOMAINS[0].id;
                                if (!stored)
                                    return def;
                                return constants_1.NEPNEP_DOMAINS.find((v) => v.id == stored)?.id ?? def;
                            },
                            set: async (value) => {
                                return store.set("n_host", value);
                            },
                        },
                    }),
                ],
            },
        ];
    }
}
exports.Target = Target;

},{"./constants":1,"./controller":2,"@suwatte/daisuke":9,"lodash":"lodash"}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const cheerio_1 = require("cheerio");
const lodash_1 = require("lodash");
const moment_1 = __importDefault(require("moment"));
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class Parser {
    THUMBNAIL_TEMPLATE = "";
    homepageSection(entries) {
        const highlights = [];
        for (const entry of entries.slice(0, constants_1.HIGHLIGHT_LIMIT)) {
            highlights.push({
                contentId: entry.IndexName,
                title: entry.SeriesName,
                cover: this.coverFor(entry.IndexName),
                // tags: entry.Genres,
            });
        }
        return highlights;
    }
    filters(html) {
        const filters = [];
        const genreStr = html.match(constants_1.PATHS.genre_tag)?.[1].replace(/'/g, '"').trim();
        const typesStr = html
            .match(constants_1.PATHS.format_tag)?.[1]
            .match(/(\[.*])/)?.[1]
            .replace(/'/g, '"')
            .trim();
        if (!genreStr || !typesStr)
            throw new Error("Failed to parse Filters");
        const genres = JSON.parse(genreStr);
        const types = JSON.parse(typesStr);
        // Genres
        filters.push({
            id: constants_1.TAG_PREFIX.genres,
            title: "Genres",
            type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
            options: genres.map((v) => ({
                id: v.toLowerCase(),
                label: v,
            })),
        });
        // Types
        filters.push({
            id: constants_1.TAG_PREFIX.type,
            title: "Types",
            type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
            options: types.map((v) => ({
                id: v.toLowerCase(),
                label: v,
            })),
        });
        return [...filters, ...constants_1.DEFAULT_FILTERS];
    }
    coverFor(id) {
        return this.THUMBNAIL_TEMPLATE.replace("{{Result.i}}", id);
    }
    toHighlight(entry) {
        return {
            contentId: entry.i,
            title: entry.s,
            cover: this.coverFor(entry.i),
        };
    }
    search(request) {
        const { filters } = request;
        const grouped = filters?.find((v) => v.id == "grouped");
        const groupedTypes = grouped?.included
            ?.filter((v) => v.startsWith(constants_1.TAG_PREFIX.type))
            .map((v) => v.split(":")?.[1])
            .filter((v) => v);
        const groupedYear = grouped?.included
            ?.filter((v) => v.startsWith(constants_1.TAG_PREFIX.year))
            .map((v) => v.split(":")?.[1])
            .filter((v) => v)?.[0];
        const orig = grouped?.included?.includes(constants_1.TAG_PREFIX.translation);
        return {
            query: request.query?.toLowerCase(),
            // Tags
            includedTags: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.genres)
                ?.included?.map(lodash_1.toLower),
            excludedTags: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.genres)
                ?.excluded?.map(lodash_1.toLower),
            // Author
            authors: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.author)
                ?.included?.map(lodash_1.toLower),
            // Status
            p_status: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.publication)
                ?.included?.map(lodash_1.toLower),
            s_status: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.scanlation)
                ?.included?.map(lodash_1.toLower),
            // Types
            includeTypes: filters?.find((v) => v.id == constants_1.TAG_PREFIX.type)?.included?.map(lodash_1.toLower) ??
                groupedTypes,
            excludeTypes: filters
                ?.find((v) => v.id == constants_1.TAG_PREFIX.type)
                ?.excluded?.map(lodash_1.toLower),
            // Original Translation
            originalTranslation: filters?.find((v) => v.id == constants_1.TAG_PREFIX.translation)?.bool ??
                orig ??
                false,
            // Release Year
            released: filters?.find((v) => v.id == constants_1.TAG_PREFIX.year)?.included?.[0] ??
                groupedYear,
        };
    }
    // Content
    content(html, id, host) {
        const $ = (0, cheerio_1.load)(html);
        const body = $(".row");
        const title = $("h1", body).text();
        if (!title)
            throw new Error("Failed to Parse Profile");
        const summary = $(".Content", body).text().split("{")[0];
        const additionalTitles = $(".list-group-item:has(span:contains(Alternate))", body)
            .text()
            .replace("Alternate Name(s):", "")
            .trim()
            .split(", ")
            .map((v) => v.trim())
            .filter((v) => v && v !== title);
        const creators = $(".list-group-item:has(span:contains(Author)) a", body)
            .map((_, v) => $(v).text())
            .toArray()
            .map((v) => v.trim())
            .filter((v) => !!v);
        // Properties
        const properties = [];
        const genres = $(".list-group-item:has(span:contains(Genre)) a", body)
            .map((_, v) => $(v).text())
            .toArray()
            .map((v) => v.trim())
            .filter((v) => !!v);
        properties.push({
            id: constants_1.TAG_PREFIX.genres,
            label: "Genres",
            tags: genres.map((v) => ({
                id: v.toLowerCase(),
                label: v,
                adultContent: constants_1.ADULT_TAGS.includes(v.toLowerCase()),
            })),
        });
        const adultContent = properties[0].tags.some((v) => v.adultContent);
        // Grouped Types, Released, Official Translation
        const groupedProperty = {
            id: "grouped",
            label: "Additional Tags",
            tags: [],
        };
        const type = $(".list-group-item:has(span:contains(Type)) a", body)
            .first()
            .text();
        const released = $(".list-group-item:has(span:contains(Released)) a", body)
            .first()
            .text();
        const officialTranslation = $(".list-group-item:has(span:contains(Official Translation)) a", body)
            .first()
            .text();
        // Type
        groupedProperty.tags.push({
            id: `${constants_1.TAG_PREFIX.type}:${type.toLowerCase()}`,
            label: type,
        });
        // Released
        groupedProperty.tags.push({
            id: `${constants_1.TAG_PREFIX.year}:${released}`,
            label: `Released in ${released}`,
        });
        // Reading Mode
        let recommendedReadingMode = daisuke_1.ReadingMode.PAGED_MANGA;
        if (constants_1.VERTICAL_TYPES.includes(type)) {
            recommendedReadingMode = daisuke_1.ReadingMode.VERTICAL;
        }
        if (officialTranslation) {
            groupedProperty.tags.push({
                id: constants_1.TAG_PREFIX.lang,
                label: "Official Translation",
            });
        }
        properties.push(groupedProperty);
        /// Authors
        properties.push({
            id: constants_1.TAG_PREFIX.author,
            label: "Author(s)",
            tags: creators.map((v) => ({
                id: v.trim().toLowerCase(),
                label: v.split(" ").map(lodash_1.capitalize).join(" ").trim(),
            })),
        });
        const statusString = $(".list-group-item:has(span:contains(Status)) a:contains(Publish)", body)
            .text()
            .replace(" (Publish)", "")
            .trim()
            .toLowerCase();
        const status = constants_1.STATUS_KEYS[statusString] ?? daisuke_1.Status.UNKNOWN;
        // Related
        const includedCollections = [];
        const relatedString = html.match(constants_1.PATHS.related)?.[1];
        if (relatedString) {
            const entries = JSON.parse(relatedString);
            const highlights = this.homepageSection(entries);
            const collection = {
                id: "related",
                title: "Related Titles",
                style: daisuke_1.CollectionStyle.NORMAL,
                highlights,
            };
            includedCollections.push(collection);
        }
        const cover = $('meta[property="og:image"]').attr("content") ?? this.coverFor(id);
        const chapters = this.chapters(html, id);
        return {
            contentId: id,
            additionalTitles,
            summary,
            cover,
            includedCollections,
            adultContent,
            recommendedReadingMode,
            title,
            status,
            properties,
            creators,
            webUrl: `${host}/manga/${id}`,
            chapters,
        };
    }
    chapters(html, contentId) {
        const str = html.match(constants_1.PATHS.chapters)?.[1];
        if (!str)
            throw new Error("Failed to Parse Chapters");
        const objects = JSON.parse(str);
        let index = 0;
        const chapters = [];
        for (const object of objects) {
            const chapterId = object.Chapter;
            const numbers = (0, utils_1.parseChapterString)(chapterId);
            chapters.push({
                chapterId,
                contentId,
                ...numbers,
                index,
                date: (0, moment_1.default)(object.Date).subtract(1, "hour").toDate(),
                language: "en_us",
            });
            index++;
        }
        return chapters;
    }
    chapterData(html, chapterId, contentId) {
        const host = html.match(constants_1.PATHS.chapter_data_domain)?.[1].replaceAll(`"`, "");
        const path = html.match(constants_1.PATHS.chapter_data_path)?.[1].replaceAll(`"`, "");
        const chapterStr = html.match(constants_1.PATHS.chapter_data_chapter)?.[1];
        if (!host || !path || !chapterStr)
            throw new Error("Unable to find info");
        const chapter = JSON.parse(chapterStr);
        const directory = chapter.Directory && chapter.Directory.length > 0
            ? `${chapter.Directory}/`
            : "";
        const c = (0, utils_1.parseChapterString)(chapter.Chapter).number.toString().split(".");
        let chapterPath = c[0];
        chapterPath = chapterPath.padStart(4, "0");
        const decimal = c[1];
        if (decimal) {
            chapterPath += `.${decimal}`;
        }
        const base = `https://${host}/manga/${path}/${directory}${chapterPath}`;
        const pageCount = chapter.Page ? parseInt(chapter.Page) : 0;
        if (!pageCount)
            throw new Error("Invalid Page Count");
        const pages = Array.from(Array(pageCount), (_, n) => ({
            url: `${base}-${(n + 1).toString().padStart(3, "0")}.png`,
        }));
        return {
            chapterId,
            contentId,
            pages,
        };
    }
}
exports.Parser = Parser;

},{"./constants":1,"./utils":6,"@suwatte/daisuke":9,"cheerio":"cheerio","lodash":"lodash","moment":"moment"}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = void 0;
const constants_1 = require("./constants");
class Store {
    store = new ObjectStore();
    async host() {
        const value = await this.store.string("n_host");
        if (typeof value !== "string")
            return constants_1.NEPNEP_DOMAINS[0].url;
        const host = constants_1.NEPNEP_DOMAINS.find((v) => v.id === value) ?? constants_1.NEPNEP_DOMAINS[0];
        return host.url;
    }
}
exports.Store = Store;

},{"./constants":1}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareURLSuffix = exports.parseChapterString = exports.dynamicSort = void 0;
const dynamicSort = (property) => {
    let sortOrder = 1;
    if (property[0] === "-") {
        sortOrder = -1;
        property = property.substr(1);
    }
    return function (a, b) {
        const result = a[property] > b[property] ? -1 : a[property] < b[property] ? 1 : 0;
        return result * sortOrder;
    };
};
exports.dynamicSort = dynamicSort;
const parseChapterString = (str) => {
    if (!str)
        throw new Error("Invalid Chapter String");
    let volume = parseInt(str[0]);
    if (Number.isNaN(volume))
        throw new Error("Invalid Chapter Volume String");
    volume -= 1;
    if (volume == 0)
        volume = undefined;
    let number = parseInt(str.slice(1));
    if (Number.isNaN(number)) {
        throw new Error("Invalid Chapter Number String");
    }
    number = number / 10;
    return { volume, number };
};
exports.parseChapterString = parseChapterString;
const prepareURLSuffix = (str) => {
    const info = (0, exports.parseChapterString)(str);
    const number = info.number;
    const volume = (info.volume ?? 0) + 1;
    let suffix = `-chapter-${number}`;
    if (volume != 1) {
        suffix += `-index-${volume}`;
    }
    suffix += ".html";
    return suffix;
};
exports.prepareURLSuffix = prepareURLSuffix;

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Source = void 0;
class Source {
}
exports.Source = Source;

},{}],8:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Source"), exports);

},{"./Source":7}],9:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./classes"), exports);
__exportStar(require("./types"), exports);

},{"./classes":8,"./types":26}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],11:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionStyle = void 0;
var CollectionStyle;
(function (CollectionStyle) {
    CollectionStyle[CollectionStyle["NORMAL"] = 0] = "NORMAL";
    CollectionStyle[CollectionStyle["INFO"] = 1] = "INFO";
    CollectionStyle[CollectionStyle["GALLERY"] = 2] = "GALLERY";
    CollectionStyle[CollectionStyle["UPDATE_LIST"] = 3] = "UPDATE_LIST";
})(CollectionStyle = exports.CollectionStyle || (exports.CollectionStyle = {}));

},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentType = exports.ReadingFlag = exports.ReadingMode = exports.Status = void 0;
// Enums
var Status;
(function (Status) {
    Status[Status["UNKNOWN"] = 0] = "UNKNOWN";
    Status[Status["ONGOING"] = 1] = "ONGOING";
    Status[Status["COMPLETED"] = 2] = "COMPLETED";
    Status[Status["CANCELLED"] = 3] = "CANCELLED";
    Status[Status["HIATUS"] = 4] = "HIATUS";
})(Status = exports.Status || (exports.Status = {}));
/**
 * The method in which the content can be read
 */
var ReadingMode;
(function (ReadingMode) {
    ReadingMode[ReadingMode["PAGED_MANGA"] = 0] = "PAGED_MANGA";
    ReadingMode[ReadingMode["PAGED_COMIC"] = 1] = "PAGED_COMIC";
    ReadingMode[ReadingMode["VERTICAL"] = 2] = "VERTICAL";
    ReadingMode[ReadingMode["VERTICAL_SEPARATED"] = 3] = "VERTICAL_SEPARATED";
    ReadingMode[ReadingMode["NOVEL"] = 4] = "NOVEL";
    ReadingMode[ReadingMode["WEB"] = 5] = "WEB";
})(ReadingMode = exports.ReadingMode || (exports.ReadingMode = {}));
var ReadingFlag;
(function (ReadingFlag) {
    ReadingFlag[ReadingFlag["READING"] = 0] = "READING";
    ReadingFlag[ReadingFlag["PLANNED"] = 1] = "PLANNED";
    ReadingFlag[ReadingFlag["COMPLETED"] = 2] = "COMPLETED";
    ReadingFlag[ReadingFlag["DROPPED"] = 3] = "DROPPED";
    ReadingFlag[ReadingFlag["REREADING"] = 4] = "REREADING";
    ReadingFlag[ReadingFlag["PAUSED"] = 5] = "PAUSED";
    ReadingFlag[ReadingFlag["UNKNOWN"] = 6] = "UNKNOWN";
})(ReadingFlag = exports.ReadingFlag || (exports.ReadingFlag = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["NOVEL"] = 0] = "NOVEL";
    ContentType[ContentType["MANGA"] = 1] = "MANGA";
    ContentType[ContentType["MANHUA"] = 2] = "MANHUA";
    ContentType[ContentType["MANHWA"] = 3] = "MANHWA";
    ContentType[ContentType["COMIC"] = 4] = "COMIC";
    ContentType[ContentType["UNKNOWN"] = 5] = "UNKNOWN";
})(ContentType = exports.ContentType || (exports.ContentType = {}));

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterType = void 0;
var FilterType;
(function (FilterType) {
    FilterType[FilterType["TOGGLE"] = 0] = "TOGGLE";
    FilterType[FilterType["SELECT"] = 1] = "SELECT";
    FilterType[FilterType["MULTISELECT"] = 2] = "MULTISELECT";
    FilterType[FilterType["EXCLUDABLE_MULTISELECT"] = 3] = "EXCLUDABLE_MULTISELECT";
    FilterType[FilterType["TEXT"] = 4] = "TEXT";
    FilterType[FilterType["INFO"] = 5] = "INFO";
})(FilterType = exports.FilterType || (exports.FilterType = {}));

},{}],15:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],16:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Types

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderLinkType = void 0;
var ProviderLinkType;
(function (ProviderLinkType) {
    ProviderLinkType[ProviderLinkType["WEBSITE"] = 0] = "WEBSITE";
    ProviderLinkType[ProviderLinkType["TWITTER"] = 1] = "TWITTER";
    ProviderLinkType[ProviderLinkType["DISCORD"] = 2] = "DISCORD";
    ProviderLinkType[ProviderLinkType["PATREON"] = 3] = "PATREON";
})(ProviderLinkType = exports.ProviderLinkType || (exports.ProviderLinkType = {}));

},{}],19:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],20:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],21:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Content"), exports);
__exportStar(require("./Highlight"), exports);
__exportStar(require("./Chapter"), exports);
__exportStar(require("./ChapterData"), exports);
__exportStar(require("./SearchRequest"), exports);
__exportStar(require("./PagedResult"), exports);
__exportStar(require("./TrackerInfo"), exports);
__exportStar(require("./Property"), exports);
__exportStar(require("./Collection"), exports);
__exportStar(require("./Provider"), exports);
__exportStar(require("./Filter"), exports);

},{"./Chapter":10,"./ChapterData":11,"./Collection":12,"./Content":13,"./Filter":14,"./Highlight":15,"./PagedResult":16,"./Property":17,"./Provider":18,"./SearchRequest":19,"./TrackerInfo":20}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMethod = void 0;
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["USERNAME_PW"] = 0] = "USERNAME_PW";
    AuthMethod[AuthMethod["EMAIL_PW"] = 1] = "EMAIL_PW";
    AuthMethod[AuthMethod["WEB"] = 2] = "WEB";
    AuthMethod[AuthMethod["OAUTH"] = 3] = "OAUTH";
})(AuthMethod = exports.AuthMethod || (exports.AuthMethod = {}));

},{}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonPreference = exports.TextFieldPreference = exports.TogglePreference = exports.StepperPreference = exports.MultiSelectPreference = exports.SelectPreference = exports.PreferenceType = void 0;
var PreferenceType;
(function (PreferenceType) {
    PreferenceType[PreferenceType["SELECT"] = 0] = "SELECT";
    PreferenceType[PreferenceType["MULTISELECT"] = 1] = "MULTISELECT";
    PreferenceType[PreferenceType["STEPPER"] = 2] = "STEPPER";
    PreferenceType[PreferenceType["TOGGLE"] = 3] = "TOGGLE";
    PreferenceType[PreferenceType["TEXTFIELD"] = 4] = "TEXTFIELD";
    PreferenceType[PreferenceType["BUTTON"] = 5] = "BUTTON";
})(PreferenceType = exports.PreferenceType || (exports.PreferenceType = {}));
class Preference {
    constructor(key, type, label, value) {
        this.key = key;
        this.type = type;
        this.label = label;
        this.value = value;
    }
}
class SelectPreference extends Preference {
    constructor({ key, label, options, value }) {
        super(key, PreferenceType.SELECT, label, value);
        this.options = options;
    }
}
exports.SelectPreference = SelectPreference;
class MultiSelectPreference extends Preference {
    constructor({ key, label, options, value, maxSelectionCount, minSelectionCount, }) {
        super(key, PreferenceType.MULTISELECT, label, value);
        this.options = options;
        this.maxSelectionCount = maxSelectionCount;
        this.minSelectionCount = minSelectionCount;
    }
}
exports.MultiSelectPreference = MultiSelectPreference;
class StepperPreference extends Preference {
    constructor({ key, value, label, minValue, maxValue, }) {
        super(key, PreferenceType.STEPPER, label, value);
        this.maxValue = maxValue;
        this.minValue = minValue;
    }
}
exports.StepperPreference = StepperPreference;
class TogglePreference extends Preference {
    constructor({ key, label, value }) {
        super(key, PreferenceType.TOGGLE, label, value);
    }
}
exports.TogglePreference = TogglePreference;
class TextFieldPreference extends Preference {
    constructor({ key, label, value }) {
        super(key, PreferenceType.TEXTFIELD, label, value);
    }
}
exports.TextFieldPreference = TextFieldPreference;
class ButtonPreference extends Preference {
    constructor({ key, label, action, systemImage, isDestructive, }) {
        super(key, PreferenceType.BUTTON, label, {
            get: function () {
                throw new Error("Method Is Never Called");
            },
            set: function (value) {
                throw new Error("Method Is Never Called");
            },
        });
        this.action = action;
        this.systemImage = systemImage;
        this.isDestructive = isDestructive;
    }
}
exports.ButtonPreference = ButtonPreference;

},{}],24:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}],25:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./Preferences"), exports);
__exportStar(require("./RunnerInfo"), exports);

},{"./Authentication":22,"./Preferences":23,"./RunnerInfo":24}],26:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./core"), exports);
__exportStar(require("./content"), exports);
__exportStar(require("./networking"), exports);

},{"./content":21,"./core":25,"./networking":27}],27:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"dup":10}]},{},[3])(3)
});
