(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.STTPackage = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllGenreTags = exports.SORTERS = exports.LANG_TAGS = exports.ORIGIN_TAGS = exports.STATUS_TAGS = exports.GENERIC_TAGS = exports.ADULT_TAGS = exports.DEMOGRAPHIC_TAGS = exports.CONTENT_TYPE_TAGS = void 0;
exports.CONTENT_TYPE_TAGS = [
    { id: "artbook", label: "Artbook", adultContent: false },
    { id: "cartoon", label: "Cartoon", adultContent: false },
    { id: "comic", label: "Comic", adultContent: false },
    { id: "doujinshi", label: "Doujinshi", adultContent: false },
    { id: "imageset", label: "Imageset", adultContent: false },
    { id: "manga", label: "Manga", adultContent: false },
    { id: "manhua", label: "Manhua", adultContent: false },
    { id: "manhwa", label: "Manhwa", adultContent: false },
    { id: "webtoon", label: "Webtoon", adultContent: false },
    { id: "western", label: "Western", adultContent: false },
];
exports.DEMOGRAPHIC_TAGS = [
    { id: "shoujo", label: "Shoujo(G)", adultContent: false },
    { id: "shounen", label: "Shounen(B)", adultContent: false },
    { id: "josei", label: "Josei(W)", adultContent: false },
    { id: "seinen", label: "Seinen(M)", adultContent: false },
    { id: "yuri", label: "Yuri(GL)", adultContent: false },
    { id: "yaoi", label: "Yaoi(BL)", adultContent: false },
    { id: "futa", label: "Futa(WL)", adultContent: true },
    { id: "bara", label: "Bara(ML)", adultContent: true },
];
exports.ADULT_TAGS = [
    { id: "gore", label: "Gore", adultContent: true },
    { id: "bloody", label: "Bloody", adultContent: true },
    { id: "violence", label: "Violence", adultContent: true },
    { id: "ecchi", label: "Ecchi", adultContent: true },
    { id: "adult", label: "Adult", adultContent: true },
    { id: "mature", label: "Mature", adultContent: true },
    { id: "smut", label: "Smut", adultContent: true },
    { id: "hentai", label: "Hentai", adultContent: true },
];
exports.GENERIC_TAGS = [
    { id: "_4_koma", label: "4-Koma", adultContent: false },
    { id: "action", label: "Action", adultContent: false },
    { id: "adaptation", label: "Adaptation", adultContent: false },
    { id: "adventure", label: "Adventure", adultContent: false },
    { id: "age_gap", label: "Age Gap", adultContent: false },
    { id: "aliens", label: "Aliens", adultContent: false },
    { id: "animals", label: "Animals", adultContent: false },
    { id: "anthology", label: "Anthology", adultContent: false },
    { id: "beasts", label: "Beasts", adultContent: false },
    { id: "bodyswap", label: "Bodyswap", adultContent: false },
    { id: "cars", label: "Cars", adultContent: false },
    {
        id: "cheating_infidelity",
        label: "Cheating/Infidelity",
        adultContent: false,
    },
    {
        id: "childhood_friends",
        label: "Childhood Friends",
        adultContent: false,
    },
    { id: "college_life", label: "College life ", adultContent: false },
    { id: "comedy", label: "Comedy", adultContent: false },
    {
        id: "contest_winning",
        label: "Contest winning",
        adultContent: false,
    },
    { id: "cooking", label: "Cooking", adultContent: false },
    { id: "crime", label: "Crime", adultContent: false },
    { id: "crossdressing", label: "Crossdressing", adultContent: false },
    { id: "delinquents", label: "Delinquents", adultContent: false },
    { id: "dementia", label: "Dementia", adultContent: false },
    { id: "demons", label: "Demons", adultContent: false },
    { id: "drama", label: "Drama", adultContent: false },
    { id: "dungeons", label: "Dungeons", adultContent: false },
    {
        id: "emperor_daughte",
        label: "Emperor's daughte",
        adultContent: false,
    },
    { id: "fantasy", label: "Fantasy", adultContent: false },
    { id: "fan_colored", label: "Fan-Colored", adultContent: false },
    { id: "fetish", label: "Fetish", adultContent: false },
    { id: "full_color", label: "Full Color", adultContent: false },
    { id: "game", label: "Game", adultContent: false },
    { id: "gender_bender", label: "Gender Bender", adultContent: false },
    { id: "genderswap", label: "Genderswap", adultContent: false },
    { id: "ghosts", label: "Ghosts", adultContent: false },
    { id: "gyaru", label: "Gyaru", adultContent: false },
    { id: "harem", label: "Harem", adultContent: false },
    { id: "harlequin", label: "Harlequin", adultContent: false },
    { id: "historical", label: "Historical", adultContent: false },
    { id: "horror", label: "Horror", adultContent: false },
    { id: "incest", label: "Incest", adultContent: false },
    { id: "isekai", label: "Isekai", adultContent: false },
    { id: "kids", label: "Kids", adultContent: false },
    { id: "loli", label: "Loli", adultContent: false },
    { id: "magic", label: "Magic", adultContent: false },
    { id: "magical_girls", label: "Magical Girls", adultContent: false },
    { id: "martial_arts", label: "Martial Arts", adultContent: false },
    { id: "mecha", label: "Mecha", adultContent: false },
    { id: "medical", label: "Medical", adultContent: false },
    { id: "military", label: "Military", adultContent: false },
    { id: "monster_girls", label: "Monster Girls", adultContent: false },
    { id: "monsters", label: "Monsters", adultContent: false },
    { id: "music", label: "Music", adultContent: false },
    { id: "mystery", label: "Mystery", adultContent: false },
    { id: "netorare", label: "Netorare/NTR", adultContent: false },
    { id: "ninja", label: "Ninja", adultContent: false },
    { id: "office_workers", label: "Office Workers", adultContent: false },
    { id: "omegaverse", label: "Omegaverse", adultContent: false },
    { id: "oneshot", label: "Oneshot", adultContent: false },
    { id: "parody", label: "parody", adultContent: false },
    { id: "philosophical", label: "Philosophical", adultContent: false },
    { id: "police", label: "Police", adultContent: false },
    {
        id: "post_apocalyptic",
        label: "Post-Apocalyptic",
        adultContent: false,
    },
    { id: "psychological", label: "Psychological", adultContent: false },
    { id: "regression", label: "Regression", adultContent: false },
    { id: "reincarnation", label: "Reincarnation", adultContent: false },
    { id: "reverse_harem", label: "Reverse Harem", adultContent: false },
    { id: "revenge", label: "Revenge", adultContent: false },
    { id: "reverse_isekai", label: "Reverse Isekai ", adultContent: false },
    { id: "romance", label: "Romance", adultContent: false },
    { id: "royal_family", label: "Royal family", adultContent: false },
    { id: "royalty", label: "Royalty", adultContent: false },
    { id: "samurai", label: "Samurai", adultContent: false },
    { id: "school_life", label: "School Life", adultContent: false },
    { id: "sci_fi", label: "Sci-Fi", adultContent: false },
    { id: "shota", label: "Shota", adultContent: false },
    { id: "shoujo_ai", label: "Shoujo ai", adultContent: false },
    { id: "shounen_ai", label: "Shounen ai", adultContent: false },
    { id: "showbiz", label: "Showbiz", adultContent: false },
    { id: "slice_of_life", label: "Slice of Life", adultContent: false },
    { id: "sm_bdsm", label: "SM/BDSM/SUB-DOM", adultContent: false },
    { id: "space", label: "Space", adultContent: false },
    { id: "sports", label: "Sports", adultContent: false },
    { id: "super_power", label: "Super Power", adultContent: false },
    { id: "superhero", label: "Superhero", adultContent: false },
    { id: "supernatural", label: "Supernatural", adultContent: false },
    { id: "survival", label: "Survival", adultContent: false },
    { id: "thriller", label: "Thriller", adultContent: false },
    { id: "time_travel", label: "Time Travel", adultContent: false },
    { id: "tower_climbing", label: "Tower Climbing", adultContent: false },
    {
        id: "traditional_games",
        label: "Traditional Games",
        adultContent: false,
    },
    { id: "tragedy", label: "Tragedy", adultContent: false },
    { id: "transmigration", label: "Transmigration", adultContent: false },
    { id: "vampires", label: "Vampires", adultContent: false },
    { id: "villainess", label: "Villainess", adultContent: false },
    { id: "video_games", label: "Video Games", adultContent: false },
    {
        id: "virtual_reality",
        label: "Virtual Reality",
        adultContent: false,
    },
    { id: "wuxia", label: "Wuxia", adultContent: false },
    { id: "xianxia", label: "Xianxia", adultContent: false },
    { id: "xuanhuan", label: "Xuanhuan", adultContent: false },
    { id: "yakuzas", label: "Yakuzas", adultContent: false },
    { id: "zombies", label: "Zombies", adultContent: false },
];
exports.STATUS_TAGS = [
    { id: "pending", label: "Pending", adultContent: false },
    { id: "ongoing", label: "Ongoing", adultContent: false },
    { id: "completed", label: "Completed", adultContent: false },
    { id: "hiatus", label: "Hiatus", adultContent: false },
    { id: "cancelled", label: "Cancelled", adultContent: false },
];
exports.ORIGIN_TAGS = [
    { id: "zh", label: "Chinese", adultContent: false },
    { id: "en", label: "English", adultContent: false },
    { id: "ja", label: "Japanese", adultContent: false },
    { id: "ko", label: "Korean", adultContent: false },
    { id: "af", label: "Afrikaans", adultContent: false },
    { id: "sq", label: "Albanian", adultContent: false },
    { id: "am", label: "Amharic", adultContent: false },
    { id: "ar", label: "Arabic", adultContent: false },
    { id: "hy", label: "Armenian", adultContent: false },
    { id: "az", label: "Azerbaijani", adultContent: false },
    { id: "be", label: "Belarusian", adultContent: false },
    { id: "bn", label: "Bengali", adultContent: false },
    { id: "bs", label: "Bosnian", adultContent: false },
    { id: "bg", label: "Bulgarian", adultContent: false },
    { id: "my", label: "Burmese", adultContent: false },
    { id: "km", label: "Cambodian", adultContent: false },
    { id: "ca", label: "Catalan", adultContent: false },
    { id: "ceb", label: "Cebuano", adultContent: false },
    { id: "zh_hk", label: "Chinese (Cantonese)", adultContent: false },
    { id: "zh_tw", label: "Chinese (Traditional)", adultContent: false },
    { id: "hr", label: "Croatian", adultContent: false },
    { id: "cs", label: "Czech", adultContent: false },
    { id: "da", label: "Danish", adultContent: false },
    { id: "nl", label: "Dutch", adultContent: false },
    { id: "en_us", label: "English (United States)", adultContent: false },
    { id: "eo", label: "Esperanto", adultContent: false },
    { id: "et", label: "Estonian", adultContent: false },
    { id: "fo", label: "Faroese", adultContent: false },
    { id: "fil", label: "Filipino", adultContent: false },
    { id: "fi", label: "Finnish", adultContent: false },
    { id: "fr", label: "French", adultContent: false },
    { id: "ka", label: "Georgian", adultContent: false },
    { id: "de", label: "German", adultContent: false },
    { id: "el", label: "Greek", adultContent: false },
    { id: "gn", label: "Guarani", adultContent: false },
    { id: "gu", label: "Gujarati", adultContent: false },
    { id: "ht", label: "Haitian Creole", adultContent: false },
    { id: "ha", label: "Hausa", adultContent: false },
    { id: "he", label: "Hebrew", adultContent: false },
    { id: "hi", label: "Hindi", adultContent: false },
    { id: "hu", label: "Hungarian", adultContent: false },
    { id: "is", label: "Icelandic", adultContent: false },
    { id: "ig", label: "Igbo", adultContent: false },
    { id: "id", label: "Indonesian", adultContent: false },
    { id: "ga", label: "Irish", adultContent: false },
    { id: "it", label: "Italian", adultContent: false },
    { id: "jv", label: "Javanese", adultContent: false },
    { id: "kn", label: "Kannada", adultContent: false },
    { id: "kk", label: "Kazakh", adultContent: false },
    { id: "ku", label: "Kurdish", adultContent: false },
    { id: "ky", label: "Kyrgyz", adultContent: false },
    { id: "lo", label: "Laothian", adultContent: false },
    { id: "lv", label: "Latvian", adultContent: false },
    { id: "lt", label: "Lithuanian", adultContent: false },
    { id: "lb", label: "Luxembourgish", adultContent: false },
    { id: "mk", label: "Macedonian", adultContent: false },
    { id: "mg", label: "Malagasy", adultContent: false },
    { id: "ms", label: "Malay", adultContent: false },
    { id: "ml", label: "Malayalam", adultContent: false },
    { id: "mt", label: "Maltese", adultContent: false },
    { id: "mi", label: "Maori", adultContent: false },
    { id: "mr", label: "Marathi", adultContent: false },
    { id: "mo", label: "Moldavian", adultContent: false },
    { id: "mn", label: "Mongolian", adultContent: false },
    { id: "ne", label: "Nepali", adultContent: false },
    { id: "no", label: "Norwegian", adultContent: false },
    { id: "ny", label: "Nyanja", adultContent: false },
    { id: "ps", label: "Pashto", adultContent: false },
    { id: "fa", label: "Persian", adultContent: false },
    { id: "pl", label: "Polish", adultContent: false },
    { id: "pt", label: "Portuguese", adultContent: false },
    { id: "pt_br", label: "Portuguese (Brazil)", adultContent: false },
    { id: "ro", label: "Romanian", adultContent: false },
    { id: "rm", label: "Romansh", adultContent: false },
    { id: "ru", label: "Russian", adultContent: false },
    { id: "sm", label: "Samoan", adultContent: false },
    { id: "sr", label: "Serbian", adultContent: false },
    { id: "sh", label: "Serbo-Croatian", adultContent: false },
    { id: "st", label: "Sesotho", adultContent: false },
    { id: "sn", label: "Shona", adultContent: false },
    { id: "sd", label: "Sindhi", adultContent: false },
    { id: "si", label: "Sinhalese", adultContent: false },
    { id: "sk", label: "Slovak", adultContent: false },
    { id: "sl", label: "Slovenian", adultContent: false },
    { id: "so", label: "Somali", adultContent: false },
    { id: "es", label: "Spanish", adultContent: false },
    {
        id: "es_419",
        label: "Spanish (Latin America)",
        adultContent: false,
    },
    { id: "sw", label: "Swahili", adultContent: false },
    { id: "sv", label: "Swedish", adultContent: false },
    { id: "tg", label: "Tajik", adultContent: false },
    { id: "ta", label: "Tamil", adultContent: false },
    { id: "th", label: "Thai", adultContent: false },
    { id: "ti", label: "Tigrinya", adultContent: false },
    { id: "to", label: "Tonga", adultContent: false },
    { id: "tr", label: "Turkish", adultContent: false },
    { id: "tk", label: "Turkmen", adultContent: false },
    { id: "uk", label: "Ukrainian", adultContent: false },
    { id: "ur", label: "Urdu", adultContent: false },
    { id: "uz", label: "Uzbek", adultContent: false },
    { id: "vi", label: "Vietnamese", adultContent: false },
    { id: "yo", label: "Yoruba", adultContent: false },
    { id: "zu", label: "Zulu", adultContent: false },
    { id: "_t", label: "Other", adultContent: false },
];
exports.LANG_TAGS = [
    { id: "en", label: "English", adultContent: false },
    { id: "ar", label: "Arabic", adultContent: false },
    { id: "bg", label: "Bulgarian", adultContent: false },
    { id: "zh", label: "Chinese", adultContent: false },
    { id: "cs", label: "Czech", adultContent: false },
    { id: "da", label: "Danish", adultContent: false },
    { id: "nl", label: "Dutch", adultContent: false },
    { id: "fil", label: "Filipino", adultContent: false },
    { id: "fi", label: "Finnish", adultContent: false },
    { id: "fr", label: "French", adultContent: false },
    { id: "de", label: "German", adultContent: false },
    { id: "el", label: "Greek", adultContent: false },
    { id: "he", label: "Hebrew", adultContent: false },
    { id: "hi", label: "Hindi", adultContent: false },
    { id: "hu", label: "Hungarian", adultContent: false },
    { id: "id", label: "Indonesian", adultContent: false },
    { id: "it", label: "Italian", adultContent: false },
    { id: "ja", label: "Japanese", adultContent: false },
    { id: "ko", label: "Korean", adultContent: false },
    { id: "ms", label: "Malay", adultContent: false },
    { id: "pl", label: "Polish", adultContent: false },
    { id: "pt", label: "Portuguese", adultContent: false },
    { id: "pt_br", label: "Portuguese (Brazil)", adultContent: false },
    { id: "ro", label: "Romanian", adultContent: false },
    { id: "ru", label: "Russian", adultContent: false },
    { id: "es", label: "Spanish", adultContent: false },
    { id: "es_419", label: "Spanish (Latin America)", adultContent: false },
    { id: "sv", label: "Swedish", adultContent: false },
    { id: "th", label: "Thai", adultContent: false },
    { id: "tr", label: "Turkish", adultContent: false },
    { id: "uk", label: "Ukrainian", adultContent: false },
    { id: "vi", label: "Vietnamese", adultContent: false },
    { id: "af", label: "Afrikaans", adultContent: false },
    { id: "sq", label: "Albanian", adultContent: false },
    { id: "am", label: "Amharic", adultContent: false },
    { id: "hy", label: "Armenian", adultContent: false },
    { id: "az", label: "Azerbaijani", adultContent: false },
    { id: "be", label: "Belarusian", adultContent: false },
    { id: "bn", label: "Bengali", adultContent: false },
    { id: "bs", label: "Bosnian", adultContent: false },
    { id: "my", label: "Burmese", adultContent: false },
    { id: "km", label: "Cambodian", adultContent: false },
    { id: "ca", label: "Catalan", adultContent: false },
    { id: "ceb", label: "Cebuano", adultContent: false },
    { id: "zh_hk", label: "Chinese (Cantonese)", adultContent: false },
    { id: "zh_tw", label: "Chinese (Traditional)", adultContent: false },
    { id: "hr", label: "Croatian", adultContent: false },
    { id: "en_us", label: "English (United States)", adultContent: false },
    { id: "eo", label: "Esperanto", adultContent: false },
    { id: "et", label: "Estonian", adultContent: false },
    { id: "fo", label: "Faroese", adultContent: false },
    { id: "ka", label: "Georgian", adultContent: false },
    { id: "gn", label: "Guarani", adultContent: false },
    { id: "gu", label: "Gujarati", adultContent: false },
    { id: "ht", label: "Haitian Creole", adultContent: false },
    { id: "ha", label: "Hausa", adultContent: false },
    { id: "is", label: "Icelandic", adultContent: false },
    { id: "ig", label: "Igbo", adultContent: false },
    { id: "ga", label: "Irish", adultContent: false },
    { id: "jv", label: "Javanese", adultContent: false },
    { id: "kn", label: "Kannada", adultContent: false },
    { id: "kk", label: "Kazakh", adultContent: false },
    { id: "ku", label: "Kurdish", adultContent: false },
    { id: "ky", label: "Kyrgyz", adultContent: false },
    { id: "lo", label: "Laothian", adultContent: false },
    { id: "lv", label: "Latvian", adultContent: false },
    { id: "lt", label: "Lithuanian", adultContent: false },
    { id: "lb", label: "Luxembourgish", adultContent: false },
    { id: "mk", label: "Macedonian", adultContent: false },
    { id: "mg", label: "Malagasy", adultContent: false },
    { id: "ml", label: "Malayalam", adultContent: false },
    { id: "mt", label: "Maltese", adultContent: false },
    { id: "mi", label: "Maori", adultContent: false },
    { id: "mr", label: "Marathi", adultContent: false },
    { id: "mo", label: "Moldavian", adultContent: false },
    { id: "mn", label: "Mongolian", adultContent: false },
    { id: "ne", label: "Nepali", adultContent: false },
    { id: "no", label: "Norwegian", adultContent: false },
    { id: "ny", label: "Nyanja", adultContent: false },
    { id: "ps", label: "Pashto", adultContent: false },
    { id: "fa", label: "Persian", adultContent: false },
    { id: "rm", label: "Romansh", adultContent: false },
    { id: "sm", label: "Samoan", adultContent: false },
    { id: "sr", label: "Serbian", adultContent: false },
    { id: "sh", label: "Serbo-Croatian", adultContent: false },
    { id: "st", label: "Sesotho", adultContent: false },
    { id: "sn", label: "Shona", adultContent: false },
    { id: "sd", label: "Sindhi", adultContent: false },
    { id: "si", label: "Sinhalese", adultContent: false },
    { id: "sk", label: "Slovak", adultContent: false },
    { id: "sl", label: "Slovenian", adultContent: false },
    { id: "so", label: "Somali", adultContent: false },
    { id: "sw", label: "Swahili", adultContent: false },
    { id: "tg", label: "Tajik", adultContent: false },
    { id: "ta", label: "Tamil", adultContent: false },
    { id: "ti", label: "Tigrinya", adultContent: false },
    { id: "to", label: "Tonga", adultContent: false },
    { id: "tk", label: "Turkmen", adultContent: false },
    { id: "ur", label: "Urdu", adultContent: false },
    { id: "uz", label: "Uzbek", adultContent: false },
    { id: "yo", label: "Yoruba", adultContent: false },
    { id: "zu", label: "Zulu", adultContent: false },
    { id: "_t", label: "Other", adultContent: false },
];
exports.SORTERS = [
    { label: "Most Views Totally", id: "views_a" },
    { label: "Most Views 365 days", id: "views_y" },
    { label: "Most Views 30 days", id: "views_m" },
    { label: "Most Views 7 days", id: "views_w" },
    { label: "Most Views 24 hours", id: "views_d" },
    { label: "Most Views 60 minutes", id: "views_h" },
    { label: "Z-A", id: "title" },
    { label: "Last Updated", id: "update" },
    { label: "Newest Added", id: "create" },
];
const getAllGenreTags = () => {
    return [
        ...exports.GENERIC_TAGS,
        ...exports.ADULT_TAGS,
        ...exports.CONTENT_TYPE_TAGS,
        ...exports.DEMOGRAPHIC_TAGS,
    ];
};
exports.getAllGenreTags = getAllGenreTags;

},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Controller = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const constants_1 = require("./constants");
const parser_1 = require("./parser");
class Controller {
    TAG_DIVIDER = ":";
    BASE = "https://bato.to";
    client = new NetworkClient();
    parser = new parser_1.Parser();
    store = new ValueStore();
    async getSearchResults(query) {
        let params = {};
        // Keyword
        if (query.query) {
            params["word"] = query.query;
        }
        // Page
        if (query.page) {
            params["page"] = query.page;
        }
        const includedTags = [];
        const excludedTags = [];
        for (const filter of query.filters ?? []) {
            switch (filter.id) {
                case "creators":
                    if (!filter.included || !filter.included[0] || params.word)
                        break;
                    params.word = filter.included[0];
                    break;
                case "origin":
                    params.origs = this.prepareFilterString(filter.included ?? [], filter.excluded ?? []);
                    break;
                case "translated":
                    params.lang = this.prepareFilterString(filter.included ?? [], filter.excluded ?? []);
                    if (!params.lang) {
                        const values = await this.store.get("content_search_langs");
                        if (values) {
                            const langs = values.split(", ");
                            params.lang = this.prepareFilterString(langs, []);
                        }
                    }
                    break;
                case "status":
                    if (!filter.included)
                        break;
                    params.release = this.prepareFilterString(filter.included, []);
                    break;
                default:
                    if (filter.included)
                        includedTags.push(...filter.included);
                    if (filter.excluded)
                        excludedTags.push(...filter.excluded);
                    break;
            }
        }
        params.sort = query.sort ?? "";
        const response = await this.client.get(`${this.BASE}/browse`, {
            params,
        });
        const results = this.parser.parsePagedResponse(response.data);
        return { page: query.page ?? 1, results, isLastPage: results.length > 60 };
    }
    prepareFilterString(included, excluded) {
        let str = included.join(",");
        if (excluded.length !== 0) {
            str += "|";
            str += excluded.join(",");
        }
        return str;
    }
    getFilters() {
        return [
            {
                id: "content_type",
                title: "Content Type",
                type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
                options: constants_1.CONTENT_TYPE_TAGS,
            },
            {
                id: "demographic",
                title: "Demographics",
                type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
                options: constants_1.DEMOGRAPHIC_TAGS,
            },
            {
                id: "adult",
                title: "Mature",
                type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
                options: constants_1.ADULT_TAGS,
            },
            {
                id: "general",
                title: "Genres",
                type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
                options: constants_1.GENERIC_TAGS,
            },
            {
                id: "origin",
                title: "Original Language",
                type: daisuke_1.FilterType.SELECT,
                options: constants_1.ORIGIN_TAGS,
            },
            {
                id: "translated",
                title: "Translated Language",
                subtitle: "NOTE: When Selected, This will override your language preferences",
                type: daisuke_1.FilterType.SELECT,
                options: constants_1.LANG_TAGS,
            },
            {
                id: "status",
                title: "Content Status",
                type: daisuke_1.FilterType.SELECT,
                options: constants_1.STATUS_TAGS,
            },
        ];
    }
    getProperties() {
        return [
            {
                id: "content_type",
                label: "Content Type",
                tags: constants_1.CONTENT_TYPE_TAGS,
            },
            {
                id: "demographic",
                label: "Demographics",
                tags: constants_1.DEMOGRAPHIC_TAGS,
            },
            {
                id: "adult",
                label: "Mature",
                tags: constants_1.ADULT_TAGS,
            },
            {
                id: "general",
                label: "Genres",
                tags: constants_1.GENERIC_TAGS,
            },
            {
                id: "origin",
                label: "Original Language",
                tags: constants_1.ORIGIN_TAGS,
            },
            {
                id: "translated",
                label: "Translated Language",
                tags: constants_1.LANG_TAGS,
            },
            {
                id: "status",
                label: "Content Status",
                tags: constants_1.STATUS_TAGS,
            },
        ];
    }
    async getContent(id) {
        const response = await this.client.get(`${this.BASE}/series/${id}`);
        return this.parser.parseContent(response.data, id);
    }
    async getChapters(id) {
        const response = await this.client.get(`${this.BASE}/series/${id}`);
        return this.parser.parseChapters(response.data, id);
    }
    async getChapterData(contentId, chapterId) {
        const response = await this.client.get(`${this.BASE}/chapter/${chapterId}`);
        return {
            contentId,
            chapterId,
            pages: this.parser.parsePages(response.data),
        };
    }
}
exports.Controller = Controller;

},{"./constants":1,"./parser":4,"@suwatte/daisuke":7}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const constants_1 = require("./constants");
const controller_1 = require("./controller");
class Target extends daisuke_1.Source {
    info = {
        id: "to.bato",
        name: "Bato",
        version: 0.2,
        website: "https://bato.to",
        supportedLanguages: [],
        nsfw: false,
        thumbnail: "bato.png",
        minSupportedAppVersion: "4.6.0",
    };
    controller = new controller_1.Controller();
    getContent(contentId) {
        return this.controller.getContent(contentId);
    }
    getChapters(contentId) {
        return this.controller.getChapters(contentId);
    }
    getChapterData(contentId, chapterId) {
        return this.controller.getChapterData(contentId, chapterId);
    }
    getSearchResults(query) {
        return this.controller.getSearchResults(query);
    }
    async getSourceTags() {
        return this.controller.getProperties();
    }
    async getSearchFilters() {
        return this.controller.getFilters();
    }
    async getSearchSorters() {
        return constants_1.SORTERS;
    }
    async getUserPreferences() {
        return [
            {
                id: "language",
                children: [
                    {
                        label: "Languages",
                        key: "content_search_langs",
                        defaultValue: "lang:en",
                        type: daisuke_1.PreferenceType.multiSelect,
                        options: constants_1.LANG_TAGS.map((v) => ({ label: v.label, value: v.id })),
                    },
                ],
            },
        ];
    }
}
exports.Target = Target;

},{"./constants":1,"./controller":2,"@suwatte/daisuke":7}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const cheerio_1 = require("cheerio");
const he_1 = require("he");
const moment_1 = __importDefault(require("moment"));
const constants_1 = require("./constants");
const crypto_js_1 = require("crypto-js");
class Parser {
    parsePagedResponse(html) {
        const ITEMS_SELECTOR = "div#series-list div.col";
        const $ = (0, cheerio_1.load)(html);
        const items = $(ITEMS_SELECTOR).toArray();
        const parseElement = (element) => {
            const item = $("a.item-cover", element);
            const imgElem = $("img", item);
            const cover = imgElem.attr("abs:src") ??
                imgElem.attr("src") ??
                imgElem.attr("data-src");
            const title = (0, he_1.decode)($("a.item-title", element).text().trim());
            const contentId = item
                .attr("href")
                ?.trim()
                .match(/series\/(\d+)/)?.[1];
            if (!title || !cover || !contentId)
                throw "Failed to Parse";
            return { contentId, cover, title };
        };
        const highlights = items.map(parseElement);
        return highlights;
    }
    parseContent(html, contentId) {
        const $ = (0, cheerio_1.load)(html);
        const infoElement = $("div#mainer div.container-fluid");
        const textFromInfo = (str) => {
            return $(`div.attr-item:contains(${str}) span`, infoElement)
                .text()
                .trim();
        };
        const workStatus = textFromInfo("Original work");
        const uploadStatus = textFromInfo("Upload status");
        let title = (0, he_1.decode)($("h3", infoElement).text().trim());
        const author = textFromInfo("Authors:");
        const artist = textFromInfo("Artists:");
        const summary = ($("div.limit-html", infoElement).text() +
            "\n" +
            $(".episode-list > .alert-warning").text().trim()).trim();
        const imgElem = $("div.attr-cover img");
        const cover = imgElem.attr("abs:src") ?? imgElem.attr("src") ?? "";
        let status = daisuke_1.Status.UNKNOWN;
        if (workStatus) {
            if (workStatus.includes("Ongoing"))
                status = daisuke_1.Status.ONGOING;
            if (workStatus.includes("Cancelled"))
                status = daisuke_1.Status.CANCELLED;
            if (workStatus.includes("Hiatus"))
                status = daisuke_1.Status.HIATUS;
            if (workStatus.includes("Completed")) {
                if (uploadStatus?.includes("Ongoing"))
                    status = daisuke_1.Status.ONGOING;
                else
                    status = daisuke_1.Status.COMPLETED;
            }
        }
        // TODO: Rank
        // Reading Mode
        const direction = textFromInfo("Read direction");
        let recommendedReadingMode = daisuke_1.ReadingMode.PAGED_MANGA;
        if (direction === "Top to Bottom")
            recommendedReadingMode = daisuke_1.ReadingMode.VERTICAL;
        else if (direction === "Left to Right")
            recommendedReadingMode = daisuke_1.ReadingMode.PAGED_COMIC;
        // Genres
        const selected = textFromInfo("Genres:")
            ?.split(", ")
            .map((v) => v.trim());
        const tags = (0, constants_1.getAllGenreTags)().filter((v) => selected.includes(v.label));
        const adultContent = tags.some((v) => v.adultContent);
        const properties = [];
        properties.push({
            id: "genres",
            label: "Genres",
            tags,
        });
        // Creators
        properties.push({
            id: "creators",
            label: "Credits",
            tags: [artist, author].map((v) => ({
                id: (0, he_1.encode)(v),
                label: v,
                adultContent: false,
            })),
        });
        const chapters = this.parseChapters(html, contentId);
        return {
            contentId,
            title,
            cover,
            summary,
            status,
            creators: [author, artist],
            recommendedReadingMode,
            properties,
            adultContent,
            chapters,
        };
    }
    parseChapters(html, contentId) {
        const $ = (0, cheerio_1.load)(html);
        const listSelector = $("div.main div.p-2").toArray();
        const chapters = [];
        let index = 0;
        for (const element of listSelector) {
            const urlElement = $("a.chapt", element);
            const chapterId = $(urlElement).attr("href")?.trim().split("/").pop();
            if (!chapterId)
                continue;
            const group = $("div.extra > a:not(.ps-3)", element).first();
            const time = $("div.extra > i.ps-3", element).text().trim();
            let title = $("span", urlElement)
                ?.text()
                .trim()
                .replace(": ", "");
            if (!title)
                title = undefined;
            const chapterText = $("b", urlElement)
                .text()
                .trim()
                .split(/Chapter|Episode|Ch\./);
            let volume = undefined;
            if (chapterText[0] && chapterText[0].includes("Vol")) {
                const volStr = chapterText[0]
                    .replace(/Volume|Vol\./, "")
                    .trim()
                    .match(/\d+/)?.[0];
                volume = Number(volStr);
                if (!volume)
                    volume = undefined;
            }
            // TODO: Better Special Chapter Handling
            let number = -1;
            const strNum = chapterText[1]?.match(/(\d+)/)?.[1];
            if (strNum) {
                number = Number(strNum) ?? -1;
                if (!number)
                    number = -1;
            }
            else {
                title = chapterText[0];
            }
            let providers = [];
            if (group) {
                const name = group.text().trim();
                const link = group.attr("href");
                if (name) {
                    providers.push({
                        id: name,
                        name,
                        links: [
                            {
                                type: daisuke_1.ProviderLinkType.WEBSITE,
                                url: (link && `https://bato.to${link}`) ?? "",
                            },
                        ],
                    });
                }
            }
            const flag = $(".item-flag").attr("data-lang");
            const language = flag ? `${flag}_${flag.toUpperCase()}` : "en_GB";
            const date = this.parseDate(time);
            chapters.push({
                chapterId,
                number,
                volume,
                date,
                contentId,
                index,
                providers,
                title,
                language,
            });
            index++;
        }
        return chapters;
    }
    parseDate(str) {
        const value = Number(str.split(" ")[0]);
        let current = (0, moment_1.default)();
        if (!value)
            return current.toDate();
        const low = str.toLowerCase();
        if (low.includes("sec"))
            return current.subtract(value, "seconds").toDate();
        else if (low.includes("min"))
            return current.subtract(value, "minutes").toDate();
        else if (low.includes("day"))
            return current.subtract(value, "days").toDate();
        else if (low.includes("week"))
            return current.subtract(value, "weeks").toDate();
        else if (low.includes("month"))
            return current.subtract(value, "months").toDate();
        else if (low.includes("year"))
            return current.subtract(value, "years").toDate();
        return current.toDate();
    }
    parsePages(html) {
        const $ = (0, cheerio_1.load)(html);
        const script = $("script:contains('const batoWord =')")?.html();
        if (!script)
            throw new Error("Could not find script with image data.");
        const imgHttpLisString = script
            .split("const imgHttpLis = ")
            .pop()
            ?.split(";")?.[0]
            .trim();
        if (!imgHttpLisString)
            throw new Error("Image List Not Found.");
        const imgHttpList = JSON.parse(imgHttpLisString);
        const batoWord = script
            .split("const batoWord = ")
            .pop()
            ?.split(";")?.[0]
            .replace(/"/g, "");
        const batoPass = script.split("const batoPass = ").pop()?.split(";")?.[0];
        if (!batoWord || !batoPass || !imgHttpList || imgHttpList.length == 0)
            throw new Error("Bad State");
        const evaluatedPass = eval(batoPass).toString();
        const imgAccListString = crypto_js_1.AES.decrypt(batoWord, evaluatedPass).toString(crypto_js_1.enc.Utf8);
        if (!imgAccListString)
            throw new Error("Invalid Acc List String");
        const imgAccList = JSON.parse(imgAccListString);
        if (!Array.isArray(imgAccList) || imgAccList.length == 0)
            throw new Error("Acc List Is Invalid");
        const urls = imgHttpList.map((v, i) => `${v}?${imgAccList[i]}`);
        return urls.map((url) => ({ url }));
    }
}
exports.Parser = Parser;

},{"./constants":1,"@suwatte/daisuke":7,"cheerio":"cheerio","crypto-js":"crypto-js","he":"he","moment":"moment"}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Source = void 0;
class Source {
}
exports.Source = Source;

},{}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Source"), exports);

},{"./Source":5}],7:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./classes"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./validation"), exports);

},{"./classes":6,"./types":25,"./validation":29}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZChapter = void 0;
const Provider_1 = require("../content/Provider");
const ChapterData_1 = require("./ChapterData");
const zod_1 = require("zod");
exports.ZChapter = zod_1.z.object({
    /**
     * Identifier for this chapter in relation to the Content
     */
    chapterId: zod_1.z.string().min(1),
    /**
     * Content Identifier to which this chapter belongs to
     */
    contentId: zod_1.z.string().min(1),
    /**
     * The Chapters Number
     */
    number: zod_1.z.number().nonnegative(),
    /**
     * The index of this chapter in relation to all chapters of the content.
     *
     * The First Most Available Chapter Should Have an Index of 0
     */
    index: zod_1.z.number().int().nonnegative(),
    /**
     * URL At which the chapter is accessible on the web
     */
    webUrl: zod_1.z.string().url().optional(),
    /**
     * Date of Publication
     */
    date: zod_1.z.date(),
    /**
     * Volume to which this chapter belongs
     */
    volume: zod_1.z.number().nonnegative().optional(),
    /**
     * Language Code of this chapter
     */
    language: zod_1.z.string().optional(),
    /**
     * Title of chapter
     */
    title: zod_1.z.string().optional(),
    /**
     * Included {@link ChapterData}
     */
    data: ChapterData_1.ZChapterData.optional(),
    /**
     * The Chapters {@link Provider}'s
     */
    providers: zod_1.z.array(Provider_1.ZProvider).optional(),
});

},{"../content/Provider":16,"./ChapterData":9,"zod":37}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZChapterData = exports.ZChapterPage = void 0;
const zod_1 = require("zod");
exports.ZChapterPage = zod_1.z.object({
    /**
     * The URL of the Image
     */
    url: zod_1.z.string().url().optional(),
    /**
     * The Image Data in the form of a base64-encoded string
     */
    raw: zod_1.z.string().optional(),
});
exports.ZChapterData = zod_1.z.object({
    /**
     * The Chapter Identifier. Should be Unique in relation to the Content.
     */
    chapterId: zod_1.z.string().min(1),
    /**
     * The Content Identifier of this Chapter, Should be Unique in relation to the Source
     */
    contentId: zod_1.z.string().min(1),
    /**
     * The Text Content Of the Chapter. This is to be populated for Novel Sources
     *
     * Can be HTML or plain text
     */
    text: zod_1.z.string().min(1).optional(),
    /**
     * The Pages of the chapter. This should be populated in standard Image Sources.
     */
    pages: zod_1.z.array(exports.ZChapterPage).optional(),
});

},{"zod":37}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZExploreCollection = exports.ZHighlightCollection = exports.ZCollectionExcerpt = exports.CollectionStyle = void 0;
const zod_1 = require("zod");
const Highlight_1 = require("./Highlight");
const SearchRequest_1 = require("./SearchRequest");
var CollectionStyle;
(function (CollectionStyle) {
    CollectionStyle[CollectionStyle["NORMAL"] = 0] = "NORMAL";
    CollectionStyle[CollectionStyle["INFO"] = 1] = "INFO";
    CollectionStyle[CollectionStyle["GALLERY"] = 2] = "GALLERY";
    CollectionStyle[CollectionStyle["UPDATE_LIST"] = 3] = "UPDATE_LIST";
})(CollectionStyle = exports.CollectionStyle || (exports.CollectionStyle = {}));
// Schemas
exports.ZCollectionExcerpt = zod_1.z.object({
    /**
     * The ID of the Collection
     */
    id: zod_1.z.string().min(1),
    /**
     * The Title of the Collection
     */
    title: zod_1.z.string().min(1),
    /**
     * The Style in which this collection should be displayed
     */
    style: zod_1.z.nativeEnum(CollectionStyle),
    /**
     * The Subtitle of the Collection.
     */
    subtitle: zod_1.z.string().optional(),
    /**
     * The Search Request to be made to view more results from this collection
     */
    request: SearchRequest_1.ZSearchRequest.optional(),
});
exports.ZHighlightCollection = exports.ZCollectionExcerpt.extend({
    /**
     * The Highlights/Titles to be displayed within this collection
     */
    highlights: zod_1.z.array(Highlight_1.ZHighlight),
});
exports.ZExploreCollection = zod_1.z.object({
    /**
     * The Populated Title of this Collection
     */
    title: zod_1.z.string().optional(),
    /**
     * The Populated Subtitle of this collection.
     */
    subtitle: zod_1.z.string().optional(),
    /**
     * The Highlights/Titles to be displayed within this collection
     */
    highlights: zod_1.z.array(Highlight_1.ZHighlight),
});

},{"./Highlight":13,"./SearchRequest":17,"zod":37}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZContent = exports.ContentType = exports.ReadingFlag = exports.ReadingMode = exports.Status = void 0;
const zod_1 = require("zod");
const Chapter_1 = require("./Chapter");
const Collection_1 = require("./Collection");
const Highlight_1 = require("./Highlight");
const Property_1 = require("./Property");
const TrackerInfo_1 = require("./TrackerInfo");
// Enums
var Status;
(function (Status) {
    Status[Status["UNKNOWN"] = 0] = "UNKNOWN";
    Status[Status["ONGOING"] = 1] = "ONGOING";
    Status[Status["COMPLETED"] = 2] = "COMPLETED";
    Status[Status["CANCELLED"] = 3] = "CANCELLED";
    Status[Status["HIATUS"] = 4] = "HIATUS";
})(Status = exports.Status || (exports.Status = {}));
/**
 * The method in which the content can be read
 */
var ReadingMode;
(function (ReadingMode) {
    ReadingMode[ReadingMode["PAGED_MANGA"] = 0] = "PAGED_MANGA";
    ReadingMode[ReadingMode["PAGED_COMIC"] = 1] = "PAGED_COMIC";
    ReadingMode[ReadingMode["VERTICAL"] = 2] = "VERTICAL";
    ReadingMode[ReadingMode["VERTICAL_SEPARATED"] = 3] = "VERTICAL_SEPARATED";
    ReadingMode[ReadingMode["NOVEL"] = 4] = "NOVEL";
    ReadingMode[ReadingMode["WEB"] = 5] = "WEB";
})(ReadingMode = exports.ReadingMode || (exports.ReadingMode = {}));
var ReadingFlag;
(function (ReadingFlag) {
    ReadingFlag[ReadingFlag["READING"] = 0] = "READING";
    ReadingFlag[ReadingFlag["PLANNED"] = 1] = "PLANNED";
    ReadingFlag[ReadingFlag["COMPLETED"] = 2] = "COMPLETED";
    ReadingFlag[ReadingFlag["DROPPED"] = 3] = "DROPPED";
    ReadingFlag[ReadingFlag["REREADING"] = 4] = "REREADING";
    ReadingFlag[ReadingFlag["PAUSED"] = 5] = "PAUSED";
    ReadingFlag[ReadingFlag["UNKNOWN"] = 6] = "UNKNOWN";
})(ReadingFlag = exports.ReadingFlag || (exports.ReadingFlag = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["NOVEL"] = 0] = "NOVEL";
    ContentType[ContentType["MANGA"] = 1] = "MANGA";
    ContentType[ContentType["MANHUA"] = 2] = "MANHUA";
    ContentType[ContentType["MANHWA"] = 3] = "MANHWA";
    ContentType[ContentType["COMIC"] = 4] = "COMIC";
    ContentType[ContentType["UNKNOWN"] = 5] = "UNKNOWN";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
// Schemas
const ZBaseContent = zod_1.z.object({
    /**
     * URL to which content is accessible on web
     */
    webUrl: zod_1.z.string().url().optional(),
    /**
     * The Publication Status of Content
     *
     * Note: Defaults to UNKNOWN if not defined.
     */
    status: zod_1.z.nativeEnum(Status).optional(),
    /**
     * Names of creators of the publication; Artists, Authors etc
     */
    creators: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * Summary / Description of the content
     */
    summary: zod_1.z.string().optional(),
    /**
     * Indicates Content Contains Adult Imagery / Text.
     *
     * Defaults to false if not defined
     */
    adultContent: zod_1.z.boolean().optional(),
    /**
     * Other Names of the Publication
     */
    additionalTitles: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * Properties of the publication
     */
    properties: zod_1.z.array(Property_1.ZProperty).optional(),
    /**
     * Content Type of the publication
     *
     * defaults to UNKNOWN if not defined
     */
    contentType: zod_1.z.nativeEnum(ContentType).optional(),
    /**
     * The Reading Mode recommended by the source based on available data.
     *
     * defaults to PAGED_COMIC if not defined
     */
    recommendedReadingMode: zod_1.z.nativeEnum(ReadingMode).optional(),
    /**
     * Properties that are non-interactive in-app. This should be used to display miscellaneous information in app.
     */
    nonInteractiveProperties: zod_1.z.array(Property_1.ZNonInteractiveProperty).optional(),
    /**
     * Additional Collections to display.
     *
     * Useful for display stuff like recommended Content
     */
    includedCollections: zod_1.z.array(Collection_1.ZHighlightCollection).optional(),
    /**
     * The Content's defined Tracking ID's.
     */
    trackerInfo: TrackerInfo_1.ZTrackerInfo.optional(),
    /**
     * The content's chapters.
     *
     * Most websites display both the content information and chapters on the same page. Use to property to populate the chapters is such is the case
     *
     * Note: If Defined Suwatte will not make the subsequent requests required to get the content's chapters in the profile view.
     */
    chapters: zod_1.z.array(Chapter_1.ZChapter).optional(),
});
exports.ZContent = Highlight_1.ZBaseInfo.merge(ZBaseContent);

},{"./Chapter":8,"./Collection":10,"./Highlight":13,"./Property":15,"./TrackerInfo":18,"zod":37}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZPopulatedFilter = exports.ZFilter = exports.FilterType = void 0;
const zod_1 = require("zod");
const Property_1 = require("./Property");
var FilterType;
(function (FilterType) {
    FilterType[FilterType["TOGGLE"] = 0] = "TOGGLE";
    FilterType[FilterType["SELECT"] = 1] = "SELECT";
    FilterType[FilterType["MULTISELECT"] = 2] = "MULTISELECT";
    FilterType[FilterType["EXCLUDABLE_MULTISELECT"] = 3] = "EXCLUDABLE_MULTISELECT";
    FilterType[FilterType["TEXT"] = 4] = "TEXT";
    FilterType[FilterType["INFO"] = 5] = "INFO";
})(FilterType = exports.FilterType || (exports.FilterType = {}));
exports.ZFilter = zod_1.z.object({
    /**
     * The ID of the filter
     */
    id: zod_1.z.string().min(1),
    /**
     * The Title of the Filter
     */
    title: zod_1.z.string().min(1),
    /**
     * The subtitle of the filter
     */
    subtitle: zod_1.z.string().min(1).optional(),
    label: zod_1.z.string().min(1).optional(),
    /**
     * The Filter Type
     */
    type: zod_1.z.nativeEnum(FilterType),
    /**
     * The Filter's Options if the filter type is SELECT,MULTISELECT,EXCLUDABLE_SELECT
     */
    options: zod_1.z.array(Property_1.ZBaseInteractable).optional(),
});
exports.ZPopulatedFilter = zod_1.z.object({
    /**
     * The Id of the Filter
     */
    id: zod_1.z.string().min(1),
    /**
     * The Boolean value if the filter is of type TOGGLE
     */
    bool: zod_1.z.boolean().optional(),
    /**
     * The Text Value of the filter if the filter is of type TEXT
     */
    text: zod_1.z.string().optional(),
    /**
     * The Selected ID if the filter if of type SELECT
     */
    selected: zod_1.z.string().optional(),
    /**
     * The Included IDS of options if the filter is of type MULTISELECT,EXCLUDABLE_SELECT
     */
    included: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * The Excluded Option IDS if the filter is of text EXCLUDABLE_MULTISELECT
     */
    excluded: zod_1.z.array(zod_1.z.string()).optional(),
});

},{"./Property":15,"zod":37}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZHighlight = exports.ZBaseInfo = void 0;
const zod_1 = require("zod");
exports.ZBaseInfo = zod_1.z.object({
    /**
     * Identifier for readable content on source
     */
    contentId: zod_1.z.string().min(1),
    /**
     * Title of content
     */
    title: zod_1.z.string().min(1),
    /**
     * Base Cover/Thumbnail for content
     */
    cover: zod_1.z.string().url(),
    /**
     * Additional Covers Provided
     */
    additionalCovers: zod_1.z.array(zod_1.z.string()).optional(),
    /**
     * Object for Populating INFO Styled Collections
     */
    stats: zod_1.z
        .object({
        views: zod_1.z.number().int().nonnegative().optional(),
        rating: zod_1.z.number().nonnegative().optional(),
        follows: zod_1.z.number().int().nonnegative().optional(),
    })
        .optional(),
    /**
     * Object for Populating LATEST styled Collections
     */
    updates: zod_1.z
        .object({
        label: zod_1.z.string().min(1),
        date: zod_1.z.date().optional(),
        count: zod_1.z.number().int().nonnegative().optional(),
    })
        .optional(),
});
exports.ZHighlight = exports.ZBaseInfo.merge(zod_1.z.object({
    /**
     * The Subtitle of this Card/Highlight
     */
    subtitle: zod_1.z.string().min(1).optional(),
    /**
     * Tags to be displayed with this title
     */
    tags: zod_1.z.array(zod_1.z.string().min(1)).optional(),
    /**
     * Additional Information about this Title
     */
    info: zod_1.z.record(zod_1.z.string()).optional(),
}));

},{"zod":37}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZPagedResult = void 0;
const zod_1 = require("zod");
const Highlight_1 = require("./Highlight");
exports.ZPagedResult = zod_1.z.object({
    /**
     * The Content Results
     */
    results: zod_1.z.array(Highlight_1.ZHighlight),
    /**
     * The Page Number of the parsed Results
     */
    page: zod_1.z.number().int().nonnegative(),
    /**
     * Boolean Indicating whether this is the last available page.
     *
     * If this value is true or the results count is 0, Suwatte will stop making subsequent pagination requests
     */
    isLastPage: zod_1.z.boolean(),
    /**
     * The Total Results Count
     */
    totalResultCount: zod_1.z.number().int().nonnegative().optional(),
});

},{"./Highlight":13,"zod":37}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZProperty = exports.ZExploreTag = exports.ZTag = exports.ZNonInteractiveProperty = exports.ZBaseInteractable = void 0;
const zod_1 = require("zod");
// Schemas
exports.ZBaseInteractable = zod_1.z.object({
    /**
     * The ID of the Interactable Object
     */
    id: zod_1.z.string().min(1),
    /**
     * The Label of the Interactable Object
     */
    label: zod_1.z.string().min(1),
});
exports.ZNonInteractiveProperty = exports.ZBaseInteractable.extend({
    /**
     * The List of Non Interactable Properties
     */
    tags: zod_1.z.array(zod_1.z.string()),
});
exports.ZTag = exports.ZBaseInteractable.extend({
    /**
     * A boolean indicating the titles marked with this tag contain Adult Content
     */
    adultContent: zod_1.z.boolean().optional(),
});
exports.ZExploreTag = exports.ZBaseInteractable.extend({
    filterId: zod_1.z.string(),
    /**
     * A URL pointing to an image to display with this tag.
     *
     * This is used in the explore page.
     */
    imageUrl: zod_1.z.string().url().optional(),
});
exports.ZProperty = exports.ZBaseInteractable.extend({
    /**
     * The List of Tags available under this property.
     */
    tags: zod_1.z.array(exports.ZTag),
});

},{"zod":37}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZProvider = exports.ZProviderLink = exports.ProviderLinkType = void 0;
const zod_1 = require("zod");
var ProviderLinkType;
(function (ProviderLinkType) {
    ProviderLinkType[ProviderLinkType["WEBSITE"] = 0] = "WEBSITE";
    ProviderLinkType[ProviderLinkType["TWITTER"] = 1] = "TWITTER";
    ProviderLinkType[ProviderLinkType["DISCORD"] = 2] = "DISCORD";
    ProviderLinkType[ProviderLinkType["PATREON"] = 3] = "PATREON";
})(ProviderLinkType = exports.ProviderLinkType || (exports.ProviderLinkType = {}));
exports.ZProviderLink = zod_1.z.object({
    /**
     * The URL of the Link
     */
    url: zod_1.z.string().url(),
    /**
     * The Type of Link.
     *
     * EG: The Providers Website, Twitter, Discord or Patreon
     */
    type: zod_1.z.nativeEnum(ProviderLinkType),
});
exports.ZProvider = zod_1.z.object({
    /**
     * The ID of the Provider in relation to the Source
     */
    id: zod_1.z.string().min(1),
    /**
     * The Name of the Provider
     */
    name: zod_1.z.string().min(1),
    /**
     * Links the Provider can be interacted with at.
     */
    links: zod_1.z.array(exports.ZProviderLink).optional(),
});

},{"zod":37}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZSearchRequest = void 0;
const zod_1 = require("zod");
const Filter_1 = require("./Filter");
exports.ZSearchRequest = zod_1.z.object({
    /**
     * The Keywords the User would like to search
     */
    query: zod_1.z.string().optional(),
    /**
     * The Page Number of the current search
     */
    page: zod_1.z.number().int().nonnegative().optional(),
    /**
     * The User Selected Sort ID
     */
    sort: zod_1.z.string().optional(),
    filters: zod_1.z.array(Filter_1.ZPopulatedFilter).optional(),
});

},{"./Filter":12,"zod":37}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZTrackerInfo = void 0;
const zod_1 = require("zod");
exports.ZTrackerInfo = zod_1.z.object({
    /**
     * The Contents Anilist ID
     */
    al: zod_1.z.string().optional(),
    /**
     * The Content's MyAnimeList ID
     */
    mal: zod_1.z.string().optional(),
    /**
     * The Content's Kitsu ID
     */
    kt: zod_1.z.string().optional(),
    /**
     * The Content's MangaUpdates ID
     */
    mu: zod_1.z.string().optional(),
});

},{"zod":37}],19:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Content"), exports);
__exportStar(require("./Highlight"), exports);
__exportStar(require("./Chapter"), exports);
__exportStar(require("./ChapterData"), exports);
__exportStar(require("./SearchRequest"), exports);
__exportStar(require("./PagedResult"), exports);
__exportStar(require("./TrackerInfo"), exports);
__exportStar(require("./Property"), exports);
__exportStar(require("./Collection"), exports);
__exportStar(require("./Provider"), exports);
__exportStar(require("./Filter"), exports);

},{"./Chapter":8,"./ChapterData":9,"./Collection":10,"./Content":11,"./Filter":12,"./Highlight":13,"./PagedResult":14,"./Property":15,"./Provider":16,"./SearchRequest":17,"./TrackerInfo":18}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZActionGroup = exports.ZAction = void 0;
const zod_1 = require("zod");
const Preferences_1 = require("../core/Preferences");
// Schemas
exports.ZAction = zod_1.z.object({
    /**
     * The Unique Key of this Action
     */
    key: zod_1.z.string().min(1),
    /**
     * The name/title of this action
     */
    title: zod_1.z.string().min(1),
    /**
     * the Subtitle to be displayed with this action
     */
    subtitle: zod_1.z.string().optional(),
    /**
     * The {@link https://developer.apple.com/sf-symbols/ SF Symbol} key to be displayed with this action
     */
    systemImage: zod_1.z.string().optional(),
    /**
     * Destructive actions are actions which delete/remove data.
     *
     * This should be set to true if the action does an irreplaceable action. e.g a full reset of preferences
     */
    isDestructive: zod_1.z.boolean().optional(),
});
exports.ZActionGroup = Preferences_1.ZUIGroup.extend({
    /**
     * The Child Actions Within this Group
     */
    children: zod_1.z.array(exports.ZAction),
});

},{"../core/Preferences":22,"zod":37}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZDownSyncedContent = exports.ZUpSyncedContent = exports.ZUser = exports.AuthMethod = void 0;
const zod_1 = require("zod");
const Content_1 = require("../content/Content");
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["USERNAME_PW"] = 0] = "USERNAME_PW";
    AuthMethod[AuthMethod["EMAIL_PW"] = 1] = "EMAIL_PW";
    AuthMethod[AuthMethod["WEB"] = 2] = "WEB";
    AuthMethod[AuthMethod["OAUTH"] = 3] = "OAUTH";
})(AuthMethod = exports.AuthMethod || (exports.AuthMethod = {}));
// Schemas
exports.ZUser = zod_1.z.object({
    /**
     * The Users ID
     */
    id: zod_1.z.string().min(1),
    /**
     * The users username
     */
    username: zod_1.z.string().min(1),
    /**
     * The users Avatar / Profile Picture
     */
    avatar: zod_1.z.string().url().optional(),
    /**
     * Additional Information about the user to be displayed
     */
    info: zod_1.z.array(zod_1.z.string()).optional(),
});
exports.ZUpSyncedContent = zod_1.z.object({
    /**
     * The ID of the Title to be synced
     */
    id: zod_1.z.string().min(1),
    /**
     * The Reading/Library flag of the title to be synced
     */
    flag: zod_1.z.nativeEnum(Content_1.ReadingFlag),
});
exports.ZDownSyncedContent = zod_1.z.object({
    /**
     * The ID of the content
     */
    id: zod_1.z.string().min(1),
    /**
     * The Title of the content
     */
    title: zod_1.z.string().min(1),
    /**
     * The Cover/Thumbnail URL of the Title Synced
     */
    cover: zod_1.z.string().url(),
    /**
     * The Reading Flag of the title synced
     */
    readingFlag: zod_1.z.nativeEnum(Content_1.ReadingFlag).optional(),
});

},{"../content/Content":11,"zod":37}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZPreferenceGroup = exports.ZUIGroup = exports.ZPreference = exports.ZSelectionOption = exports.PreferenceType = void 0;
const zod_1 = require("zod");
var PreferenceType;
(function (PreferenceType) {
    PreferenceType[PreferenceType["select"] = 0] = "select";
    PreferenceType[PreferenceType["multiSelect"] = 1] = "multiSelect";
    PreferenceType[PreferenceType["stepper"] = 2] = "stepper";
    PreferenceType[PreferenceType["toggle"] = 3] = "toggle";
    PreferenceType[PreferenceType["textfield"] = 4] = "textfield";
})(PreferenceType = exports.PreferenceType || (exports.PreferenceType = {}));
// Schemas
exports.ZSelectionOption = zod_1.z.object({
    /**
     * The label of this selection
     */
    label: zod_1.z.string(),
    /**
     * The value of the selection, This must be unique in relation to it's parent preference
     */
    value: zod_1.z.string(),
});
exports.ZPreference = zod_1.z.object({
    /**
     * The Unique Key which is used to identify this Preference
     */
    key: zod_1.z.string().min(1),
    /**
     * The Name of the Preference
     */
    label: zod_1.z.string().min(1),
    /**
     * The Type of Preference Option
     *
     * This affects how it will be displayed within the app and what additional properties will be used
     */
    type: zod_1.z.nativeEnum(PreferenceType),
    /**
     * The Default Value of this preference
     *
     * Note: Each preference type have different ways of parsing it's values
     * * SELECT - The Value of the option
     * * MULTISELECT - A comma separated string containing the values of the selected options
     * * STEPPER - The Numerical Value as a string
     * * Toggle - The Boolean value as a string
     * * Textfield - The Inputted Text.
     */
    defaultValue: zod_1.z.string(),
    /**
     * The Options available for this preference
     *
     * This is **only** used when preference type is either SELECT or MULTISELECT
     */
    options: zod_1.z.array(exports.ZSelectionOption).optional(),
    // * ---
    /**
     * The Minimum Possible Stepper Value
     *
     * This is **only** used when the preference type is set to STEPPER
     */
    minStepperValue: zod_1.z.number().optional(),
    /**
     * The Maximum Possible Stepper Value
     *
     * This is **only** used when the preference type is set to STEPPER
     */
    maxStepperValue: zod_1.z.number().optional(),
    // * ---
    /**
     * The Minimum Number of selections possible
     *
     * This is **only** used when the preference type is set to MULTISELECT
     */
    minSelectionCount: zod_1.z.number().optional(),
    /**
     * The maximum Number of selections possible
     *
     * This is **only** used when the preference type is set to MULTISELECT
     */
    maxSelectionCount: zod_1.z.number().optional(),
});
exports.ZUIGroup = zod_1.z.object({
    /**
     * The ID of this UIGroup
     *
     * This will be displayed as a section within a list in-app
     */
    id: zod_1.z.string().min(1),
    /**
     * The Header to be displayed for this group
     */
    header: zod_1.z.string().optional(),
    /**
     * The Footer to be displayed for this group
     */
    footer: zod_1.z.string().optional(),
});
exports.ZPreferenceGroup = exports.ZUIGroup.extend({
    /**
     * The preferences to be displayed within this UIGroup
     */
    children: zod_1.z.array(exports.ZPreference),
});

},{"zod":37}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],24:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./Preferences"), exports);
__exportStar(require("./RunnerInfo"), exports);
__exportStar(require("./Actions"), exports);

},{"./Actions":20,"./Authentication":21,"./Preferences":22,"./RunnerInfo":23}],25:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./core"), exports);
__exportStar(require("./content"), exports);
__exportStar(require("./networking"), exports);

},{"./content":19,"./core":24,"./networking":28}],26:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],27:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],28:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./NetworkRequest"), exports);
__exportStar(require("./NetworkResponse"), exports);

},{"./NetworkRequest":26,"./NetworkResponse":27}],29:[function(require,module,exports){
"use strict";
/**
 * These help with schema validation checks in tests
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validate = void 0;
const zod_1 = require("zod");
const types_1 = require("../types");
const object = {
    content: (object) => {
        types_1.ZContent.parse(object);
        return true;
    },
    chapter: (object) => {
        types_1.ZChapter.parse(object);
        return true;
    },
    pagedResult: (object) => {
        types_1.ZPagedResult.parse(object);
        return true;
    },
    chapterData: (object) => {
        types_1.ZChapterData.parse(object);
        return true;
    },
    chapterPage: (object) => {
        types_1.ZChapterPage.parse(object);
        return true;
    },
    collectionExcerpt: (object) => {
        types_1.ZCollectionExcerpt.parse(object);
        return true;
    },
    highlight: (object) => {
        types_1.ZHighlight.parse(object);
        return true;
    },
    highlightCollection: (object) => {
        types_1.ZHighlightCollection.parse(object);
        return true;
    },
    property: (object) => {
        types_1.ZProperty.parse(object);
        return true;
    },
    filter: (object) => {
        types_1.ZFilter.parse(object);
        return true;
    },
    downSyncedContent: (object) => {
        types_1.ZDownSyncedContent.parse(object);
        return true;
    },
};
const array = {
    content: (object) => {
        zod_1.z.array(types_1.ZContent).parse(object);
        return true;
    },
    chapter: (object) => {
        zod_1.z.array(types_1.ZChapter).parse(object);
        return true;
    },
    pagedResult: (object) => {
        zod_1.z.array(types_1.ZPagedResult).parse(object);
        return true;
    },
    chapterData: (object) => {
        zod_1.z.array(types_1.ZChapterData).parse(object);
        return true;
    },
    chapterPage: (object) => {
        zod_1.z.array(types_1.ZChapterPage).parse(object);
        return true;
    },
    collectionExcerpt: (object) => {
        zod_1.z.array(types_1.ZCollectionExcerpt).parse(object);
        return true;
    },
    highlight: (object) => {
        zod_1.z.array(types_1.ZHighlight).parse(object);
        return true;
    },
    highlightCollection: (object) => {
        zod_1.z.array(types_1.ZHighlightCollection).parse(object);
        return true;
    },
    property: (object) => {
        zod_1.z.array(types_1.ZProperty).parse(object);
        return true;
    },
    filter: (object) => {
        zod_1.z.array(types_1.ZFilter).parse(object);
        return true;
    },
    downSyncedContent: (object) => {
        zod_1.z.array(types_1.ZDownSyncedContent).parse(object);
        return true;
    },
};
exports.Validate = {
    object,
    array,
};

},{"../types":25,"zod":37}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
const util_1 = require("./helpers/util");
exports.ZodIssueCode = util_1.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
exports.quotelessJson = quotelessJson;
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
exports.ZodError = ZodError;
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

},{"./helpers/util":36}],31:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
const en_1 = __importDefault(require("./locales/en"));
exports.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
exports.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
exports.getErrorMap = getErrorMap;

},{"./locales/en":38}],32:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./errors"), exports);
__exportStar(require("./helpers/parseUtil"), exports);
__exportStar(require("./helpers/typeAliases"), exports);
__exportStar(require("./helpers/util"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./ZodError"), exports);

},{"./ZodError":30,"./errors":31,"./helpers/parseUtil":34,"./helpers/typeAliases":35,"./helpers/util":36,"./types":39}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorUtil = void 0;
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil = exports.errorUtil || (exports.errorUtil = {}));

},{}],34:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
const errors_1 = require("../errors");
const en_1 = __importDefault(require("../locales/en"));
const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
exports.makeIssue = makeIssue;
exports.EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = (0, exports.makeIssue)({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            (0, errors_1.getErrorMap)(),
            en_1.default, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
exports.addIssueToContext = addIssueToContext;
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return exports.INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return exports.INVALID;
            if (value.status === "aborted")
                return exports.INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
exports.ParseStatus = ParseStatus;
exports.INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
exports.DIRTY = DIRTY;
const OK = (value) => ({ status: "valid", value });
exports.OK = OK;
const isAborted = (x) => x.status === "aborted";
exports.isAborted = isAborted;
const isDirty = (x) => x.status === "dirty";
exports.isDirty = isDirty;
const isValid = (x) => x.status === "valid";
exports.isValid = isValid;
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
exports.isAsync = isAsync;

},{"../errors":31,"../locales/en":38}],35:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParsedType = exports.ZodParsedType = exports.util = void 0;
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util = exports.util || (exports.util = {}));
exports.ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return exports.ZodParsedType.undefined;
        case "string":
            return exports.ZodParsedType.string;
        case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
            return exports.ZodParsedType.boolean;
        case "function":
            return exports.ZodParsedType.function;
        case "bigint":
            return exports.ZodParsedType.bigint;
        case "symbol":
            return exports.ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return exports.ZodParsedType.array;
            }
            if (data === null) {
                return exports.ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
        default:
            return exports.ZodParsedType.unknown;
    }
};
exports.getParsedType = getParsedType;

},{}],37:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.z = void 0;
const mod = __importStar(require("./external"));
exports.z = mod;
__exportStar(require("./external"), exports);
exports.default = mod;

},{"./external":32}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../helpers/util");
const ZodError_1 = require("../ZodError");
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
            if (issue.received === util_1.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(issue.minimum)}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(issue.maximum)}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1.util.assertNever(issue);
    }
    return { message };
};
exports.default = errorMap;

},{"../ZodError":30,"../helpers/util":36}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.objectUtil = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
const errors_1 = require("./errors");
const errorUtil_1 = require("./helpers/errorUtil");
const parseUtil_1 = require("./helpers/parseUtil");
const util_1 = require("./helpers/util");
const ZodError_1 = require("./ZodError");
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        return this._path.concat(this._key);
    }
}
const handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError_1.ZodError(ctx.common.issues);
        return { success: false, error };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1.getParsedType)(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodError_1.ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
exports.ZodType = ZodType;
exports.Schema = ZodType;
exports.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
// interface IsDateStringOptions extends StringDateOptions {
/**
 * Match any configuration
 */
// any?: boolean;
// }
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil_1.errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
exports.ZodString = ZodString;
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.number,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util_1.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
exports.ZodNumber = ZodNumber;
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.date,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util_1.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
exports.ZodDate = ZodDate;
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.null,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodNull = ZodNull;
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodAny = ZodAny;
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.never,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
}
exports.ZodNever = ZodNever;
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.void,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
exports.ZodVoid = ZodVoid;
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodArray = ZodArray;
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////
/////////////////////////////////////////
//////////                     //////////
//////////      ZodObject      //////////
//////////                     //////////
/////////////////////////////////////////
/////////////////////////////////////////
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return ZodArray.create(deepPartialify(schema.element));
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") {
            }
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
    }
}
exports.ZodObject = ZodObject;
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
exports.ZodUnion = ZodUnion;
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1.getParsedType)(a);
    const bType = (0, util_1.getParsedType)(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === util_1.ZodParsedType.date &&
        bType === util_1.ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
exports.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
exports.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
exports.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.map,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
exports.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.set,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return parseUtil_1.INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
exports.ZodSet = ZodSet;
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.function,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return (0, parseUtil_1.OK)(async (...args) => {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return (0, parseUtil_1.OK)((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
exports.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
exports.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
exports.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
exports.ZodEnum = ZodEnum;
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string &&
            ctx.parsedType !== util_1.ZodParsedType.number) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util_1.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
exports.ZodNativeEnum = ZodNativeEnum;
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
            ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
exports.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                // if (base.status === "aborted") return INVALID;
                // if (base.status === "dirty") {
                //   return { status: "dirty", value: base.value };
                // }
                if (!(0, parseUtil_1.isValid)(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!(0, parseUtil_1.isValid)(base))
                        return base;
                    // if (base.status === "aborted") return INVALID;
                    // if (base.status === "dirty") {
                    //   return { status: "dirty", value: base.value };
                    // }
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util_1.util.assertNever(effect);
    }
}
exports.ZodEffects = ZodEffects;
exports.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodOptional = ZodOptional;
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
exports.ZodNullable = ZodNullable;
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
exports.ZodDefault = ZodDefault;
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const result = this._def.innerType._parse({
            data: ctx.data,
            path: ctx.path,
            parent: {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: [], // don't collect issues from inner type
                },
            },
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid" ? result.value : this._def.catchValue(),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue(),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
exports.ZodCatch = ZodCatch;
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1.ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
exports.ZodNaN = ZodNaN;
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
exports.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
exports.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
exports.ZodPipeline = ZodPipeline;
const custom = (check, params = {}, fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            if (!check(data)) {
                const p = typeof params === "function" ? params(data) : params;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal });
            }
        });
    return ZodAny.create();
};
exports.custom = custom;
exports.late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
// new approach that works for abstract classes
// but requires TS 4.4+
class Class {
    constructor(..._) { }
}
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => (0, exports.custom)((data) => data instanceof cls, params, true);
exports.instanceof = instanceOfType;
const stringType = ZodString.create;
exports.string = stringType;
const numberType = ZodNumber.create;
exports.number = numberType;
const nanType = ZodNaN.create;
exports.nan = nanType;
const bigIntType = ZodBigInt.create;
exports.bigint = bigIntType;
const booleanType = ZodBoolean.create;
exports.boolean = booleanType;
const dateType = ZodDate.create;
exports.date = dateType;
const symbolType = ZodSymbol.create;
exports.symbol = symbolType;
const undefinedType = ZodUndefined.create;
exports.undefined = undefinedType;
const nullType = ZodNull.create;
exports.null = nullType;
const anyType = ZodAny.create;
exports.any = anyType;
const unknownType = ZodUnknown.create;
exports.unknown = unknownType;
const neverType = ZodNever.create;
exports.never = neverType;
const voidType = ZodVoid.create;
exports.void = voidType;
const arrayType = ZodArray.create;
exports.array = arrayType;
const objectType = ZodObject.create;
exports.object = objectType;
const strictObjectType = ZodObject.strictCreate;
exports.strictObject = strictObjectType;
const unionType = ZodUnion.create;
exports.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
exports.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
exports.intersection = intersectionType;
const tupleType = ZodTuple.create;
exports.tuple = tupleType;
const recordType = ZodRecord.create;
exports.record = recordType;
const mapType = ZodMap.create;
exports.map = mapType;
const setType = ZodSet.create;
exports.set = setType;
const functionType = ZodFunction.create;
exports.function = functionType;
const lazyType = ZodLazy.create;
exports.lazy = lazyType;
const literalType = ZodLiteral.create;
exports.literal = literalType;
const enumType = ZodEnum.create;
exports.enum = enumType;
const nativeEnumType = ZodNativeEnum.create;
exports.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
exports.promise = promiseType;
const effectsType = ZodEffects.create;
exports.effect = effectsType;
exports.transformer = effectsType;
const optionalType = ZodOptional.create;
exports.optional = optionalType;
const nullableType = ZodNullable.create;
exports.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
exports.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
exports.pipeline = pipelineType;
const ostring = () => stringType().optional();
exports.ostring = ostring;
const onumber = () => numberType().optional();
exports.onumber = onumber;
const oboolean = () => booleanType().optional();
exports.oboolean = oboolean;
exports.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
exports.NEVER = parseUtil_1.INVALID;

},{"./ZodError":30,"./errors":31,"./helpers/errorUtil":33,"./helpers/parseUtil":34,"./helpers/util":36}]},{},[3])(3)
});
