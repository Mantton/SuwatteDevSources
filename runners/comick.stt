(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.STTPackage = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXPLORE_COLLECTIONS = exports.LANGUAGE_OPTIONS = exports.getProperties = exports.GENRE_OPTIONS = exports.DEMOGRAPHIC_OPTIONS = exports.TYPE_OPTIONS = exports.SORT_OPTIONS = void 0;
const daisuke_1 = require("@suwatte/daisuke");
exports.SORT_OPTIONS = [
    { label: "Most Followed", id: "user_follow_count" },
    { label: "Most Viewed", id: "view" },
    { label: "Top Rated", id: "rating" },
    { label: "Last Updated", id: "uploaded" },
];
exports.TYPE_OPTIONS = [
    { label: "Manga", id: "jp" },
    { label: "Manhwa", id: "kr" },
    { label: "Manhua", id: "cn" },
];
exports.DEMOGRAPHIC_OPTIONS = [
    { label: "Shounen", id: "1" },
    { label: "Shoujo", id: "2" },
    { label: "Seinen", id: "3" },
    { label: "Josei", id: "4" },
];
exports.GENRE_OPTIONS = [
    { label: "4-Koma", id: "4-koma" },
    { label: "Action", id: "action" },
    { label: "Adaptation", id: "adaptation" },
    { label: "Adult", id: "adult" },
    { label: "Adventure", id: "adventure" },
    { label: "Aliens", id: "aliens" },
    { label: "Animals", id: "animals" },
    { label: "Anthology", id: "anthology" },
    { label: "Award Winning", id: "award-winning" },
    { label: "Comedy", id: "comedy" },
    { label: "Cooking", id: "cooking" },
    { label: "Crime", id: "crime" },
    { label: "Crossdressing", id: "crossdressing" },
    { label: "Delinquents", id: "delinquents" },
    { label: "Demons", id: "demons" },
    { label: "Doujinshi", id: "doujinshi" },
    { label: "Drama", id: "drama" },
    { label: "Ecchi", id: "ecchi" },
    { label: "Fan Colored", id: "fan-colored" },
    { label: "Fantasy", id: "fantasy" },
    { label: "Full Color", id: "full-color" },
    { label: "Gender Bender", id: "gender-bender" },
    { label: "Genderswap", id: "genderswap" },
    { label: "Ghosts", id: "ghosts" },
    { label: "Gore", id: "gore" },
    { label: "Gyaru", id: "gyaru" },
    { label: "Harem", id: "harem" },
    { label: "Historical", id: "historical" },
    { label: "Horror", id: "horror" },
    { label: "Incest", id: "incest" },
    { label: "Isekai", id: "isekai" },
    { label: "Loli", id: "loli" },
    { label: "Long Strip", id: "long-strip" },
    { label: "Mafia", id: "mafia" },
    { label: "Magic", id: "magic" },
    { label: "Magical Girls", id: "magical-girls" },
    { label: "Martial Arts", id: "martial-arts" },
    { label: "Mature", id: "mature" },
    { label: "Mecha", id: "mecha" },
    { label: "Medical", id: "medical" },
    { label: "Military", id: "military" },
    { label: "Monster Girls", id: "monster-girls" },
    { label: "Monsters", id: "monsters" },
    { label: "Music", id: "music" },
    { label: "Mystery", id: "mystery" },
    { label: "Ninja", id: "ninja" },
    { label: "Office Workers", id: "office-workers" },
    { label: "Official Colored", id: "official-colored" },
    { label: "Oneshot", id: "oneshot" },
    { label: "Philosophical", id: "philosophical" },
    { label: "Police", id: "police" },
    { label: "Post-Apocalyptic", id: "post-apocalyptic" },
    { label: "Psychological", id: "psychological" },
    { label: "Reincarnation", id: "reincarnation" },
    { label: "Reverse Harem", id: "reverse-harem" },
    { label: "Romance", id: "romance" },
    { label: "Samurai", id: "samurai" },
    { label: "School Life", id: "school-life" },
    { label: "Sci-Fi", id: "sci-fi" },
    { label: "Sexual Violence", id: "sexual-violence" },
    { label: "Shota", id: "shota" },
    { label: "Shoujo Ai", id: "shoujo-ai" },
    { label: "Shounen Ai", id: "shounen-ai" },
    { label: "Slice of Life", id: "slice-of-life" },
    { label: "Smut", id: "smut" },
    { label: "Sports", id: "sports" },
    { label: "Superhero", id: "superhero" },
    { label: "Supernatural", id: "supernatural" },
    { label: "Survival", id: "survival" },
    { label: "Thriller", id: "thriller" },
    { label: "Time Travel", id: "time-travel" },
    { label: "Traditional Games", id: "traditional-games" },
    { label: "Tragedy", id: "tragedy" },
    { label: "User Created", id: "user-created" },
    { label: "Vampires", id: "vampires" },
    { label: "Video Games", id: "video-games" },
    { label: "Villainess", id: "villainess" },
    { label: "Virtual Reality", id: "virtual-reality" },
    { label: "Web Comic", id: "web-comic" },
    { label: "Wuxia", id: "wuxia" },
    { label: "Yaoi", id: "yaoi" },
    { label: "Yuri", id: "yuri" },
    { label: "Zombies", id: "zombies" },
];
const getProperties = () => {
    const properties = [];
    // Type
    properties.push({
        id: "type",
        label: "Content Type",
        tags: exports.TYPE_OPTIONS.map((v) => ({
            ...v,
            id: `type:${v.id}`,
            adultContent: false,
        })),
    });
    // Demographic
    properties.push({
        id: "demographic",
        label: "Content Demographics",
        tags: exports.DEMOGRAPHIC_OPTIONS.map((v) => ({
            ...v,
            id: `demographic:${v.id}`,
            adultContent: false,
        })),
    });
    // Genre
    properties.push({
        id: "Genre",
        label: "Genres",
        tags: exports.GENRE_OPTIONS.map((v) => ({
            ...v,
            id: `genre:${v.id}`,
            adultContent: false,
        })),
    });
    return properties;
};
exports.getProperties = getProperties;
exports.LANGUAGE_OPTIONS = [
    { value: "all", label: "All Languages" },
    { value: "en", label: "English" },
    { value: "pt-br", label: "Portuguese (Brazil)" },
    { value: "ru", label: "Russian" },
    { value: "fr", label: "French" },
    { value: "es-419", label: "Spanish (Latin America)" },
    { value: "pl", label: "Polish" },
    { value: "tr", label: "Turkish" },
    { value: "it", label: "Italian" },
    { value: "es", label: "Spanish" },
    { value: "id", label: "Indonesian" },
    { value: "hu", label: "Hungarian" },
    { value: "vi", label: "Vietnamese" },
    { value: "zh-hk", label: "Chinese (Hong Kong)" },
    { value: "ar", label: "Arabic" },
    { value: "de", label: "German" },
    { value: "zh", label: "Chinese" },
    { value: "ca", label: "Catalan" },
    { value: "bg", label: "Bulgarian" },
    { value: "th", label: "Thai" },
    { value: "fa", label: "Persian" },
    { value: "uk", label: "Ukrainian" },
    { value: "mn", label: "Mongolian" },
    { value: "ro", label: "Romanian" },
    { value: "he", label: "Hebrew" },
    { value: "ms", label: "Malay" },
    { value: "tl", label: "Tagalog" },
    { value: "ja", label: "Japanese" },
    { value: "hi", label: "Hindi" },
    { value: "my", label: "Burmese" },
    { value: "ko", label: "Korean" },
    { value: "cs", label: "Czech" },
    { value: "pt", label: "Portuguese" },
    { value: "nl", label: "Dutch" },
    { value: "sv", label: "Swedish" },
    { value: "bn", label: "Bengali" },
    { value: "no", label: "Norwegian" },
    { value: "lt", label: "Lithuanian" },
    { value: "el", label: "Greek" },
    { value: "sr", label: "Serbian" },
    { value: "da", label: "Danish" },
];
exports.EXPLORE_COLLECTIONS = [
    {
        id: "hot_updates",
        title: "Hot Updates",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "recently_added",
        title: "Recently Added Titles",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "most_viewed_7",
        title: "Most Viewed Titles This Week",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "most_viewed_30",
        title: "Most Viewed Titles This Month",
        style: daisuke_1.CollectionStyle.GALLERY,
    },
    {
        id: "popular_new_7",
        title: "Popular Titles This Week",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "popular_new_30",
        title: "Most Viewed Titles This Month",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "completed",
        title: "Completed Titles",
        subtitle: "Binge-Worthy Completed Titles.",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "recently_followed",
        title: "Recent Follows",
        subtitle: "What others are reading.",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "popular_ongoing",
        title: "Popular Ongoing Titles",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "upcoming",
        title: "Up n' Coming",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "top_followed_7",
        title: "Top Followed Titles This Week",
        style: daisuke_1.CollectionStyle.INFO,
    },
    {
        id: "top_followed_30",
        title: "Top Followed Titles This Month",
        style: daisuke_1.CollectionStyle.NORMAL,
    },
    {
        id: "latest",
        title: "Latest Updates",
        style: daisuke_1.CollectionStyle.UPDATE_LIST,
    },
];

},{"@suwatte/daisuke":6}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const constants_1 = require("./constants");
const utilts_1 = require("./utilts");
class Target extends daisuke_1.Source {
    info = {
        id: "app.comick",
        name: "ComicK",
        version: 0.3,
        website: "https://comick.app/home",
        supportedLanguages: [],
        nsfw: false,
        thumbnail: "comick.png",
        minSupportedAppVersion: "5.0",
    };
    client = new NetworkClient();
    store = new ObjectStore();
    API_URL = "https://api.comick.fun";
    async getContent(contentId) {
        const data = await this.getManga(contentId);
        const content = (0, utilts_1.MangaToContent)(data, contentId);
        return content;
    }
    async getChapters(contentId) {
        const manga = await this.getManga(contentId);
        const { chapter_count: limit, hid } = manga.comic;
        if (!limit || !hid)
            throw new Error("Could Not Get Chapter Count");
        const url = `${this.API_URL}/comic/${hid}/chapters`;
        const lang = (await this.store.get("n_content_lang"));
        const { data: response } = await this.client.get(url, {
            params: {
                ...(lang && lang !== "all" && { lang }),
                ...{ tachiyomi: "true", limit },
            },
        });
        const { chapters: data } = JSON.parse(response);
        const chapters = data.map((v, index) => ({
            ...(0, utilts_1.CKChapterToChapter)(v),
            contentId,
            index,
        }));
        return chapters;
    }
    async getChapterData(contentId, chapterId) {
        const url = `${this.API_URL}/chapter/${chapterId}?tachiyomi=true`;
        const { data } = await this.client.get(url);
        const images = JSON.parse(data).chapter.images;
        const pages = images.map((v) => ({ url: v.url }));
        return {
            contentId,
            chapterId,
            pages,
        };
    }
    async getSearchResults(query) {
        const { queryString, core: params } = (0, utilts_1.parseSearchRequest)(query);
        const url = `${this.API_URL}/v1.0/search?${queryString.replace("&", "")}`;
        const response = await this.client.get(url, { params });
        const data = JSON.parse(response.data);
        return {
            page: query.page ?? 1,
            results: data.map((v) => (0, utilts_1.MangaToHighlight)(v)),
            isLastPage: data.length < 30,
        };
    }
    async getSourceTags() {
        return (0, constants_1.getProperties)();
    }
    async getSourcePreferences() {
        return [
            {
                id: "lang",
                header: "Language",
                children: [
                    new daisuke_1.SelectPreference({
                        key: "n_content_lang",
                        label: "Language",
                        options: constants_1.LANGUAGE_OPTIONS,
                        value: {
                            get: async () => {
                                return ((await this.store.get("n_content_lang")) ??
                                    "all");
                            },
                            set: async (v) => {
                                return await this.store.set("n_content_lang", v);
                            },
                        },
                    }),
                ],
                footer: "Languages in which chapters will be available",
            },
        ];
    }
    async getSearchSorters() {
        return constants_1.SORT_OPTIONS;
    }
    async getSearchFilters() {
        const properties = (0, constants_1.getProperties)();
        return [
            {
                id: "content_type",
                title: "Content Type",
                type: daisuke_1.FilterType.SELECT,
                options: properties[0].tags,
            },
            {
                id: "demographic",
                title: "Demographic",
                type: daisuke_1.FilterType.MULTISELECT,
                options: properties[1].tags,
            },
            {
                id: "genres",
                title: "Genres",
                type: daisuke_1.FilterType.EXCLUDABLE_MULTISELECT,
                options: properties[2].tags,
            },
            {
                id: "completed",
                title: "Content Status",
                label: "Completed",
                type: daisuke_1.FilterType.TOGGLE,
            },
        ];
    }
    // Helpers
    async getManga(slug) {
        const url = `${this.API_URL}/comic/${slug}`;
        const response = await this.client.get(url, {
            params: { tachiyomi: "true" },
        });
        return JSON.parse(response.data);
    }
    async willRequestImage(request) {
        request.headers = {
            ...request.headers,
            referer: "https://comic.app/",
        };
        return request;
    }
    // Explore Page
    homepage;
    async willResolveExploreCollections() {
        const { data } = await this.client.get("https://comick.app/home");
        const str = data
            .split(`<script id="__NEXT_DATA__" type="application/json">`)
            .pop()
            ?.split("</script>")?.[0];
        if (!str)
            throw new Error("Could not find Homepage JSON");
        this.homepage = JSON.parse(str).props.pageProps;
    }
    async createExploreCollections() {
        return constants_1.EXPLORE_COLLECTIONS;
    }
    async resolveExploreCollection(excerpt) {
        let highlights;
        switch (excerpt.id) {
            case "hot_updates":
                return {
                    ...excerpt,
                    highlights: await this.getUpdateHighlights(true),
                };
            case "recently_added":
                highlights = this.homepage.news.map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "most_viewed_7":
                highlights = this.homepage.trending["7"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "most_viewed_30":
                highlights = this.homepage.trending["30"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "popular_new_7":
                highlights = this.homepage.topFollowNewComics["7"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "popular_new_30":
                highlights = this.homepage.topFollowNewComics["30"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "completed":
                highlights = this.homepage.completions.map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "recently_followed":
                highlights = this.homepage.follows.map((v) => (0, utilts_1.MDComicToHighlight)(v.md_comics));
                return { ...excerpt, highlights };
            case "popular_ongoing":
                highlights = this.homepage.rank.map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "upcoming":
                highlights = this.homepage.recentRank.map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "top_followed_7":
                highlights = this.homepage.topFollowComics["7"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "top_followed_30":
                highlights = this.homepage.topFollowComics["30"].map((v) => (0, utilts_1.MDComicToHighlight)(v));
                return { ...excerpt, highlights };
            case "latest":
                return {
                    ...excerpt,
                    highlights: await this.getUpdateHighlights(false),
                };
        }
        throw "Not Ready";
    }
    async getUpdateHighlights(hot) {
        const { data: str } = await this.client.get("https://api.comick.app/chapter", {
            params: {
                page: "1",
                order: hot ? "hot" : "new",
            },
        });
        const data = JSON.parse(str)?.map((v) => (0, utilts_1.MDComicToHighlight)(v.md_comics));
        return data;
    }
}
exports.Target = Target;

},{"./constants":1,"./utilts":3,"@suwatte/daisuke":6}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDComicToHighlight = exports.CKChapterToChapter = exports.MangaToContent = exports.MangaToHighlight = exports.parseSearchRequest = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const parseSearchRequest = (request) => {
    const limit = 30;
    const sort = request.sort ?? "view";
    const page = request.page ?? 1;
    const type = "comic";
    const advanced = "1";
    const tachiyomi = "true";
    let queryString = "";
    for (const filter of request.filters ?? []) {
        switch (filter.id) {
            case "content_type":
                if (filter.included)
                    queryString +=
                        "&" + filter.included.map((v) => `country=${v}`).join("&");
                break;
            case "demographic":
                if (filter.included)
                    queryString +=
                        "&" + filter.included.map((v) => `demographic=${v}`).join("&");
                break;
            case "genres":
                if (filter.included)
                    queryString +=
                        "&" + filter.included.map((v) => `genres=${v}`).join("&");
                if (filter.excluded)
                    "&" + filter.excluded.map((v) => `excluded=${v}`).join("&");
                break;
            case "completed":
                if (filter.bool)
                    queryString += `&completed=true`;
                break;
            case "tags":
                if (filter.included)
                    queryString +=
                        "&" + filter.included.map((v) => `tags=${v}`).join("&");
        }
    }
    return {
        queryString,
        core: {
            limit,
            sort,
            page,
            type,
            advanced,
            tachiyomi,
            q: request.query ?? "",
        },
    };
};
exports.parseSearchRequest = parseSearchRequest;
const MangaToHighlight = (manga) => {
    return {
        contentId: manga.slug,
        title: manga.title,
        cover: manga.cover_url,
        stats: {
            follows: manga.user_follow_count,
            rating: manga.rating ? Number(manga.rating) : undefined,
            views: manga.view_count,
        },
    };
};
exports.MangaToHighlight = MangaToHighlight;
const MangaToContent = (data, contentId) => {
    const { comic, artists, authors, genres: ckGenres, matureContent } = data;
    const { title, links, hentai, user_follow_count, follow_rank, comment_count, follow_count, desc: summary, year, bayesian_rating, md_titles, mu_comics, status: ckStatus, cover_url: cover, translation_completed, } = comic;
    const creators = artists
        .map((v) => v.name)
        .concat(authors.map((v) => v.name));
    // Additional Titles
    const additionalTitles = [];
    if (md_titles) {
        additionalTitles.push(...md_titles.map((v) => v.title));
    }
    // Adult Content
    const adultContent = (matureContent ?? false) || (hentai ?? false);
    const muGenres = mu_comics?.mu_comic_categories?.map((v) => v.mu_categories);
    const properties = [];
    // Base Genres
    properties.push({
        id: "genres",
        label: "Genres",
        tags: ckGenres.map((v) => ({
            id: v.slug,
            label: v.name,
            adultContent: false,
        })),
    });
    // MU Tags
    if (muGenres) {
        properties.push({
            id: "tags",
            label: "Tags",
            tags: muGenres.map((v) => ({
                id: v.slug,
                label: v.title,
                adultContent: false,
            })),
        });
    }
    // * Reading Mode
    let recommendedReadingMode = daisuke_1.ReadingMode.PAGED_MANGA;
    const longStripId = "long-strip";
    const fullColorId = "full-color";
    const mapped = ckGenres.map((v) => v.slug);
    if (mapped.includes(longStripId)) {
        recommendedReadingMode = daisuke_1.ReadingMode.VERTICAL;
    }
    else if (mapped.includes(fullColorId)) {
        recommendedReadingMode = daisuke_1.ReadingMode.PAGED_COMIC;
    }
    const webUrl = `https://comick.app/comic/${contentId}`;
    const status = convertStatus(ckStatus ?? 99);
    const genTags = [];
    if (year)
        genTags.push(`Released ${year}`);
    if (bayesian_rating)
        genTags.push(`Bayesian Rating: ${bayesian_rating}`);
    if (follow_rank)
        genTags.push(`No. ${follow_rank} Most Followed Title`);
    if (follow_count) {
        let b = follow_count;
        if (user_follow_count)
            b += user_follow_count;
        genTags.push(`${b} Follows`);
    }
    if (translation_completed)
        genTags.push("Translation Completed");
    if (comment_count)
        genTags.push(`${comment_count} Onsite Comments`);
    const nonInteractive = {
        id: "general",
        label: "Additional Info",
        tags: genTags,
    };
    const trackerInfo = Array.isArray(links) ? undefined : links;
    return {
        contentId,
        title,
        adultContent,
        cover,
        additionalTitles,
        creators,
        recommendedReadingMode,
        webUrl,
        status,
        summary,
        properties,
        trackerInfo,
        nonInteractiveProperties: [nonInteractive],
    };
};
exports.MangaToContent = MangaToContent;
const convertStatus = (val) => {
    switch (val) {
        case 1:
            return daisuke_1.Status.ONGOING;
        case 2:
            return daisuke_1.Status.COMPLETED;
        case 3:
            return daisuke_1.Status.CANCELLED;
        case 4:
            return daisuke_1.Status.HIATUS;
        default:
            return daisuke_1.Status.UNKNOWN;
    }
};
const CKChapterToChapter = (data) => {
    const { title, chap, vol, lang, created_at, hid: chapterId, group_name, } = data;
    let number = Number(chap);
    if (Number.isNaN(number)) {
        number = 0.0;
    }
    return {
        date: new Date(created_at),
        chapterId,
        number,
        language: lang,
        ...(group_name && {
            providers: group_name.map((v) => ({ id: v, name: v, links: [] })),
        }),
        ...(vol && Number(vol) && { volume: Number(vol) }),
        ...(title && { title }),
    };
};
exports.CKChapterToChapter = CKChapterToChapter;
const MDComicToHighlight = (data) => {
    return {
        contentId: data.slug,
        title: data.title,
        cover: `https://meo.comick.pictures/${data.md_covers?.[0].b2key ?? ""}`,
    };
};
exports.MDComicToHighlight = MDComicToHighlight;

},{"@suwatte/daisuke":6}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Source = void 0;
class Source {
}
exports.Source = Source;

},{}],5:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Source"), exports);

},{"./Source":4}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./classes"), exports);
__exportStar(require("./types"), exports);

},{"./classes":5,"./types":23}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],8:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionStyle = void 0;
var CollectionStyle;
(function (CollectionStyle) {
    CollectionStyle[CollectionStyle["NORMAL"] = 0] = "NORMAL";
    CollectionStyle[CollectionStyle["INFO"] = 1] = "INFO";
    CollectionStyle[CollectionStyle["GALLERY"] = 2] = "GALLERY";
    CollectionStyle[CollectionStyle["UPDATE_LIST"] = 3] = "UPDATE_LIST";
})(CollectionStyle = exports.CollectionStyle || (exports.CollectionStyle = {}));

},{}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentType = exports.ReadingFlag = exports.ReadingMode = exports.Status = void 0;
// Enums
var Status;
(function (Status) {
    Status[Status["UNKNOWN"] = 0] = "UNKNOWN";
    Status[Status["ONGOING"] = 1] = "ONGOING";
    Status[Status["COMPLETED"] = 2] = "COMPLETED";
    Status[Status["CANCELLED"] = 3] = "CANCELLED";
    Status[Status["HIATUS"] = 4] = "HIATUS";
})(Status = exports.Status || (exports.Status = {}));
/**
 * The method in which the content can be read
 */
var ReadingMode;
(function (ReadingMode) {
    ReadingMode[ReadingMode["PAGED_MANGA"] = 0] = "PAGED_MANGA";
    ReadingMode[ReadingMode["PAGED_COMIC"] = 1] = "PAGED_COMIC";
    ReadingMode[ReadingMode["VERTICAL"] = 2] = "VERTICAL";
    ReadingMode[ReadingMode["VERTICAL_SEPARATED"] = 3] = "VERTICAL_SEPARATED";
    ReadingMode[ReadingMode["NOVEL"] = 4] = "NOVEL";
    ReadingMode[ReadingMode["WEB"] = 5] = "WEB";
})(ReadingMode = exports.ReadingMode || (exports.ReadingMode = {}));
var ReadingFlag;
(function (ReadingFlag) {
    ReadingFlag[ReadingFlag["READING"] = 0] = "READING";
    ReadingFlag[ReadingFlag["PLANNED"] = 1] = "PLANNED";
    ReadingFlag[ReadingFlag["COMPLETED"] = 2] = "COMPLETED";
    ReadingFlag[ReadingFlag["DROPPED"] = 3] = "DROPPED";
    ReadingFlag[ReadingFlag["REREADING"] = 4] = "REREADING";
    ReadingFlag[ReadingFlag["PAUSED"] = 5] = "PAUSED";
    ReadingFlag[ReadingFlag["UNKNOWN"] = 6] = "UNKNOWN";
})(ReadingFlag = exports.ReadingFlag || (exports.ReadingFlag = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["NOVEL"] = 0] = "NOVEL";
    ContentType[ContentType["MANGA"] = 1] = "MANGA";
    ContentType[ContentType["MANHUA"] = 2] = "MANHUA";
    ContentType[ContentType["MANHWA"] = 3] = "MANHWA";
    ContentType[ContentType["COMIC"] = 4] = "COMIC";
    ContentType[ContentType["UNKNOWN"] = 5] = "UNKNOWN";
})(ContentType = exports.ContentType || (exports.ContentType = {}));

},{}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterType = void 0;
var FilterType;
(function (FilterType) {
    FilterType[FilterType["TOGGLE"] = 0] = "TOGGLE";
    FilterType[FilterType["SELECT"] = 1] = "SELECT";
    FilterType[FilterType["MULTISELECT"] = 2] = "MULTISELECT";
    FilterType[FilterType["EXCLUDABLE_MULTISELECT"] = 3] = "EXCLUDABLE_MULTISELECT";
    FilterType[FilterType["TEXT"] = 4] = "TEXT";
    FilterType[FilterType["INFO"] = 5] = "INFO";
})(FilterType = exports.FilterType || (exports.FilterType = {}));

},{}],12:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],13:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Types

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderLinkType = void 0;
var ProviderLinkType;
(function (ProviderLinkType) {
    ProviderLinkType[ProviderLinkType["WEBSITE"] = 0] = "WEBSITE";
    ProviderLinkType[ProviderLinkType["TWITTER"] = 1] = "TWITTER";
    ProviderLinkType[ProviderLinkType["DISCORD"] = 2] = "DISCORD";
    ProviderLinkType[ProviderLinkType["PATREON"] = 3] = "PATREON";
})(ProviderLinkType = exports.ProviderLinkType || (exports.ProviderLinkType = {}));

},{}],16:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],17:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],18:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Content"), exports);
__exportStar(require("./Highlight"), exports);
__exportStar(require("./Chapter"), exports);
__exportStar(require("./ChapterData"), exports);
__exportStar(require("./SearchRequest"), exports);
__exportStar(require("./PagedResult"), exports);
__exportStar(require("./TrackerInfo"), exports);
__exportStar(require("./Property"), exports);
__exportStar(require("./Collection"), exports);
__exportStar(require("./Provider"), exports);
__exportStar(require("./Filter"), exports);

},{"./Chapter":7,"./ChapterData":8,"./Collection":9,"./Content":10,"./Filter":11,"./Highlight":12,"./PagedResult":13,"./Property":14,"./Provider":15,"./SearchRequest":16,"./TrackerInfo":17}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMethod = void 0;
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["USERNAME_PW"] = 0] = "USERNAME_PW";
    AuthMethod[AuthMethod["EMAIL_PW"] = 1] = "EMAIL_PW";
    AuthMethod[AuthMethod["WEB"] = 2] = "WEB";
    AuthMethod[AuthMethod["OAUTH"] = 3] = "OAUTH";
})(AuthMethod = exports.AuthMethod || (exports.AuthMethod = {}));

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonPreference = exports.TextFieldPreference = exports.TogglePreference = exports.StepperPreference = exports.MultiSelectPreference = exports.SelectPreference = exports.PreferenceType = void 0;
var PreferenceType;
(function (PreferenceType) {
    PreferenceType[PreferenceType["SELECT"] = 0] = "SELECT";
    PreferenceType[PreferenceType["MULTISELECT"] = 1] = "MULTISELECT";
    PreferenceType[PreferenceType["STEPPER"] = 2] = "STEPPER";
    PreferenceType[PreferenceType["TOGGLE"] = 3] = "TOGGLE";
    PreferenceType[PreferenceType["TEXTFIELD"] = 4] = "TEXTFIELD";
    PreferenceType[PreferenceType["BUTTON"] = 5] = "BUTTON";
})(PreferenceType = exports.PreferenceType || (exports.PreferenceType = {}));
class Preference {
    constructor(key, type, label, value) {
        this.key = key;
        this.type = type;
        this.label = label;
        this.value = value;
    }
}
class SelectPreference extends Preference {
    constructor({ key, label, options, value }) {
        super(key, PreferenceType.SELECT, label, value);
        this.options = options;
    }
}
exports.SelectPreference = SelectPreference;
class MultiSelectPreference extends Preference {
    constructor({ key, label, options, value, maxSelectionCount, minSelectionCount, }) {
        super(key, PreferenceType.MULTISELECT, label, value);
        this.options = options;
        this.maxSelectionCount = maxSelectionCount;
        this.minSelectionCount = minSelectionCount;
    }
}
exports.MultiSelectPreference = MultiSelectPreference;
class StepperPreference extends Preference {
    constructor({ key, value, label, minValue, maxValue, }) {
        super(key, PreferenceType.STEPPER, label, value);
        this.maxValue = maxValue;
        this.minValue = minValue;
    }
}
exports.StepperPreference = StepperPreference;
class TogglePreference extends Preference {
    constructor({ key, label, value }) {
        super(key, PreferenceType.TOGGLE, label, value);
    }
}
exports.TogglePreference = TogglePreference;
class TextFieldPreference extends Preference {
    constructor({ key, label, value }) {
        super(key, PreferenceType.TEXTFIELD, label, value);
    }
}
exports.TextFieldPreference = TextFieldPreference;
class ButtonPreference extends Preference {
    constructor({ key, label, action, systemImage, isDestructive, }) {
        super(key, PreferenceType.BUTTON, label, {
            get: function () {
                throw new Error("Method Is Never Called");
            },
            set: function (value) {
                throw new Error("Method Is Never Called");
            },
        });
        this.action = action;
        this.systemImage = systemImage;
        this.isDestructive = isDestructive;
    }
}
exports.ButtonPreference = ButtonPreference;

},{}],21:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],22:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./Preferences"), exports);
__exportStar(require("./RunnerInfo"), exports);

},{"./Authentication":19,"./Preferences":20,"./RunnerInfo":21}],23:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./core"), exports);
__exportStar(require("./content"), exports);
__exportStar(require("./networking"), exports);

},{"./content":18,"./core":22,"./networking":24}],24:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}]},{},[2])(2)
});
